#!/bin/bash
#
# birdseye
#
# Birdseye creates a simple, well-presented HTML based report of a Linux
# systems hardware, software and configuration details.
# See http://www.maxwellspangler.com/scripts/birdseye for more information.

# Copyright 2013 Maxwell Spangler, maxwell@maxwellspangler.com

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the 
# Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Version number set here: date produced plus a daily sequence version
VERSION="2023-1014-01"

# Bash variable UID returns the user id # of the user
# Running as root, or running this script using sudo should return user 0
SUDO_USER="null"
if [ $UID != 0 ]
then
	echo "You must be root or use 'sudo' to run birdseye."
	exit 1
else
	# When this script is called using 'sudo' OR 'su' this records
	# the name of the non-root user so we can set security to this
	# user on our output files. Same as 'who am i'
	SUDO_USER=$(who -m | awk '{ print $1 }')
fi

#----------------------------------------------------------------------------
#
# Functions 
#
#----------------------------------------------------------------------------

# Output a string of text to the html file
# with no line break so multiple strings can be placed on one line
function string {
	echo -n -e "${1}" >> $HTML
}

# Output a string of text to the html file
# with a trailing line break for readability
function line {
	echo -e "${1}" >> $HTML
}

# Output a string of text to the html file
# Wrap it in <p> so it can be styled as a line
function paragraph {
	echo -e "<p>${1}</p>" >> $HTML
}

#paragraph "<a href=\"#toc_bootmsgs\">Boot messages</a>"

# Output a section name *for the table of contents*
# with a named anchor ($1) and a text string ($2)
function toc_master {
	echo -e "<p class=toc_master_paragraph><a href=\"${1}\">${2}</a></p>" >> $HTML
}

# Output a section header *for the table of contents* (<h2>)
# with a named anchor ($1) and a text string ($2)
function toc_section {
	echo -e "<h2><a name=\"$1\"><a href=\"$3\">$2</a></a></h2>" >> $HTML
}

# Output a section header *for detail reporting (non-toc!)* (<h2>)
# with a named anchor ($1) and a text string ($2)
function section {
	# Output section information to HTML report file
	echo -e "<h2><a name=\"$1\">$2</a></h2>" >> $HTML
#	echo -e "<h2><a name=\"$1\">$2</a> <a href="#top" class="boxtop">Table of Contents</a></h2>" >> $HTML

	# Output name of section to user as status report
	echo "$2"
}

# Output a title that can be used to group one or more related items
# together in a group
function group_title {

	RAW_CMD=${3:-"null"}

	# If a third parameter has been passed, put it in parenthesis
	# without bold 
	if [[ $RAW_CMD != "null" ]]
	then
		echo -e "<h3><a name=\"$1\">$2 <span class=h3_nobold>($3)</span></a> <a href="#top" class="boxtop">Table of Contents</a></h3>" >> $HTML
	else
		echo -e "<h3><a name=\"$1\">$2</a> <a href="#top" class="boxtop">Table of Contents</a></h3>" >> $HTML
	fi
}

# Output a title for a single item of data being reported
function raw_caption {

	RAW_CMD=${3:-"null"}

	# If a third parameter has been passed, put it in parenthesis
	# without bold 
	if [[ $RAW_CMD != "null" ]]
	then
		echo -e "<h5><a name=\"$1\">$2 <span class=h5_nobold>($3)</span></a><a href="#top" class="boxtop">Table of Contents</a></h5>" >> $HTML
	else
		echo -e "<h5><a name=\"$1\">$2</a><a href="#top" class="boxtop">Table of Contents</a></h5>" >> $HTML
	fi
}


# Output a title for a single item of data being reported
function item_title {

	RAW_CMD=${3:-"null"}

	# If a third parameter has been passed, put it in parenthesis
	# without bold 
	if [[ $RAW_CMD != "null" ]]
	then
		echo -e "<h4><a name=\"$1\">$2 <span class=h4_nobold>($3)</span></a><a href="#top" class="boxtop">Table of Contents</a></h4>" >> $HTML
	else
		echo -e "<h4><a name=\"$1\">$2</a><a href="#top" class="boxtop">Table of Contents</a></h4>" >> $HTML
	fi
}

# Output a bullet (<li>) entry 
# with a section reference ($1) and a text string ($2)
function list {

	RAW_CMD=${3:-"null"}

	# If a third parameter has been passed, put it in parenthesis
	# without bold 
	if [[ $RAW_CMD != "null" ]]
	then
		echo -e "<li><a href=\"#$1\">$2 <span class=list_nobold>($3)</span></a></li>" >> $HTML
	else
		echo -e "<li><a href=\"#$1\">$2</a></li>" >> $HTML
	fi
}

# Output a simple unordered list tag <ul> with optional class info
function unordered_list_open {
	echo -e "<ul $1>" >> $HTML
}

# Output a simple unordered list tag <ul>
# with optional class info
function unordered_list_close {
	echo -e "</ul>" >> $HTML
}

# Output a simple unordered list tag <ul> with optional class info
function raw_open {

	# WARNING
	# Output using <pre> such as HTML that contains > and < characters
	# needs to be converted to HTML values using sed like this:
	#	lspci -vv | sed "s/>/\&rsaquo;/g" | sed "s/</\&lsaquo;/g" >> $HTML 2>&1 

	echo -e "<pre class=\"programlisting\">" >> $HTML
}

# Output a simple unordered list tag <ul> with optional class info
function raw_close {
	echo -e "</pre>" >> $HTML
}

# Output a simple unordered list tag <ul> with optional class info
function textarea_open {
	echo -e "<textarea class=\"raw_textarea\" readonly wrap=hard cols=\"$1\" rows=\"$2\">" >> $HTML
}

# Output a simple unordered list tag <ul> with optional class info
# "</p> afterwards adds a little extra space before the next line
function textarea_close {
	echo -e "</textarea></p>" >> $HTML
}

# When we have raw text to output, call this function and let it
# choose between raw_open for short output and textarea_open for long output
function text_open {

	OUTPUT_LINES=${1:-0}
	VIEWPORT_HORIZONTAL_SIZE=${2:-"120"}
	VIEWPORT_VERTICAL_SIZE=${3:-"24"}

	# For short (<= 15) lines of output, use raw_open to keep things
	# short and simple.
	# For long (> 15) lines of output, use textarea so the user can scroll
	# and resize the output window
	if [[ $OUTPUT_LINES -le 15 ]]
	then
		raw_open
		_LAST_TEXT_OPEN="raw_open"
	else
		textarea_open $VIEWPORT_HORIZONTAL_SIZE $VIEWPORT_VERTICAL_SIZE
		_LAST_TEXT_OPEN="textarea_open"
	fi
}

# Close a raw output text box that was opened using text_open
# The box opened is either 'raw_open' or 'textarea_open' and was recorded
# by the text_open function into the global LAST_TEXT_OPEN variable
# Use the value of that variable to perform either 'raw_close' or
# 'textarea_close' then rest the _LAST_TEXT_OPEN variable
function text_close {

	if [[ $_LAST_TEXT_OPEN == "raw_open" ]]
	then
		raw_close
		_LAST_TEXT_OPEN="closed"
	elif [[ $_LAST_TEXT_OPEN == "textarea_open" ]]
	then
		textarea_close
		_LAST_TEXT_OPEN="closed"
	else
		_LAST_TEXT_OPEN="unknown-error"
	fi

}

# Output a simple unordered list tag <ul> with optional class info
function helpful_tip {
	echo -e "<div class=\"tip\">" >> $HTML
	echo -e "<blockquote class=\"tip\">" >> $HTML
	echo -e "$1" >> $HTML
	echo -e "</blockquote>" >> $HTML
	echo -e "</div>" >> $HTML
}

# This function checks to see if a program is installed
function check_for_program {
	# Use whereis to see if the file exists
	CMD_WHEREIS=$(whereis $1)

	# Remove the name of the program and a colon from the whereis output
	CMD_WHEREIS=${CMD_WHEREIS#"$1:"}

	# The string should be empty if the file is missing
	# The string should have locations for the file if it exists
	if [[ X$CMD_WHEREIS == X ]]
	then
		FILE_EXISTS="no"
	else
		FILE_EXISTS="yes"
	fi
}

# This large bit of code produces a user-friendly table that summarizes
# network device information
# It also exists as a separate program called 'nics'
function nic_list {

	# This code used when calling the external script during development
#	./nics >> $HTML 2>&1

	# integrate 'nics' bash code here to avoid external calls 
	# ----- cut here -----

	# default style for Birdseye is 'traffic'
	NIC_SUMMARY_STYLE="traffic"

	# Process command line arguments
	while [ "$1" != "" ]
	do
		case $1 in

			# Default, output limited to < 80 characters wide
			-s | "--short" )
				shift
				NIC_SUMMARY_STYLE="short";;

			# Wider, shows per device traffic summary
			-t | "--traffic" )
				shift
				NIC_SUMMARY_STYLE="traffic";;

			# Wider still, shows ipv6 addresses 
			-6 | "--ipv6" )
				shift
				NIC_SUMMARY_STYLE="ipv6";;

			# Wider still, shows ipv6 addresses 
			"--debug" )
				shift
				DEBUG="yes";;

			# I don't know what I want! Help me!
			-h | --help | --syntax | *)
				usage
				exit 0;;

		esac
	done

	# Print the header for our summary table
	case $NIC_SUMMARY_STYLE in 
		"short") 
			printf "%12s %17s %8s %18s %7s %9s\n" \
				"INTERFACE" "MAC ADDRESS" "LINK" "IP ADDRESS" "MTU" ;;
		"traffic") 
			printf "%12s %17s %8s %18s %7s %9s %8s %-3s %8s %-3s\n" \
				"INTERFACE" "MAC ADDRESS" "LINK" "IP ADDRESS" "MTU" "WIRE SPD" "" "RX" "" "TX";;
		"ipv6") 
			printf "%12s %17s %8s %18s %40s %8s %9s %8s %-3s %8s %-3s\n" \
				"INTERFACE" "MAC ADDRESS" "LINK" "IP ADDRESS" "IP6 ADDRESS" "MTU" "WIRE SPD" "" "RX" "" "TX";;
	esac

	# FIND A LIST OF NETWORK DEVICES:
	# 1: ip link list - lists all network devices
	# 2: Use only the first line using a regex that looks for '1:', '99:', etc
	# 3: From that first line, we only want the device name which is param #2
	# 4: remove the colon that sits to the right of the device name
	# 5: macvtap bridges (used with KVM) look like this:
	#    macvtap0@p10p1
	#    convert the "@" symbol to ATSYMBOL and then we'll use a bash
	#    parameter expansion below to remove everything to the right of ATSYMBOL

	for EACH_NIC in $(ip link list | grep -e "[0-9]: " | awk -F " " '{print $2}' | sed "s/://g" | sed "s/@/ATSYMBOL/" )
	do

		# If ATSYMBOL is present, remove everything to right of it so we have
		# just a simple name like macvtap0
		EACH_NIC=${EACH_NIC%%ATSYMBOL*}

		if [[ $DEBUG == "yes" ]]
		then
			echo "Processing: $EACH_NIC"
			ip -oneline -stats link show $EACH_NIC >> link.show.txt
		fi

		# If we're anything but the software-only loopback device, try to find the
		# hardware MAC address this device
		if [[ $EACH_NIC != "lo" ]]
		then

			# 1: Use 'ip link show' to find addresses for this device
			# 2: We only care about the link/ether line for our information
			# 3: Return the second parameter of this line which is the MAC address
			MAC_ADDRESS=$(ip address show $EACH_NIC | grep -F "link/ether" | awk '{FS=" "; print $2}')

			# If it's not set, make it blank.
			MAC_ADDRESS=${MAC_ADDRESS:-" "}
		else
			# If we're a loopback device, ignore the need for a MAC address
			MAC_ADDRESS="none"
		fi

		# Is the link up or down or something else?
		# 1: Use 'ip link show' to show link status of this device
		# 2: We only want the first line of output which has a number: value on it
		# 3: The ninth parameter should be our link state
		# Great opportunity for perl/python regex handling instead of parameter #s
		LINK_STATE=$( ip link show $EACH_NIC | grep -e "[0-9]: " | awk '{FS=" "; print $9}')

		# If it's not set, make it blank.
		LINK_STATE=${LINK_STATE:-" "}

		# Uppercase results are cold and boring: let's make them friendly with lowercase
		# Anything that's not up/down/unknown gets presented literally because
		# it's unusual and we don't want to filter it.
		case $LINK_STATE in
			"UP") LINK_STATE="up";;
			"DOWN") LINK_STATE="down";;
			"UNKNOWN") LINK_STATE="unknown";;
		esac

		# DETERMINE IP ADDRESS of this port
		# 1: Use 'ip addr show' to get address information for this device
		# 2: Only look for lines that contain 'inet ' (they have address info)
		# 3: We only want the primary address so take the first line only
		# 4: Return the second parameter of this line which is our IP address
		IP_ADDRESS=$(ip addr show $EACH_NIC | grep "inet " | head -1 | awk '{FS=" ";print $2}')

		# If it's not set, make it blank.
		IP_ADDRESS=${IP_ADDRESS:-"none"}

		# DETERMINE IP6 ADDRESS of this port
		# 1: Use 'ip addr show' to get address information for this device
		# 2: Only look for lines that contain 'inet6 ' (they have ipv6 address info)
		# 3: Only pay attention to 'global' lines which is external ipv6 addresses??
		# 4: We only want the primary address so take the first line only
		# 5: Return the second parameter of this line which is our IP address
		# NOT SURE ABOUT THE GLOBAL CHECK! 2013.1016 maxwell
		# NOT SURE ABOUT THE GLOBAL CHECK! 2013.1016 maxwell
		IP6_ADDRESS=$(ip addr show $EACH_NIC | grep "inet6 " | grep global | head -1 | awk '{FS=" ";print $2}')

		# If it's not set, make it blank.
		IP6_ADDRESS=${IP6_ADDRESS:-"none"}

		# DETERMINE THE MTU of this port
		# 1: Use 'ip link show' to get device information
		# 2: Only look for lines containing port names at their front [0-9]:
		# 3: Return the 5th parameter which is the MTU value
		MTU=$( ip link show $EACH_NIC | grep -e "[0-9]: " | awk '{FS=" "; print $5}')

		# If it's not set, make it blank.
		MTU=${MTU:-"none"}

		# set to null here
		MASTER_NIC=""

		# The output of 'ip -oneline -stats line show' varies depending
	  # on whether the device is a NIC or a BRIDGE and other factors.
		# We've seen columns added on some devices but not others,
		# So we identify them, capture their data, and strip them out.
	  # After doing so the resulting line is in a predicable state

		# 1. Check for a 'Master'+(value) column pair seen with virbr0-nic
		# 2. Check for a 'Mode'+(value) column pair
		# 3. Process the resulting output

		# Capture the output of ip link show once here and re-use it repeatedly
		IP_LINK_SHOW_OUTPUT=$(ip -oneline -stats link show $EACH_NIC)

		# KVM makes 'virbr0-nic' lines for VM's nics and includes two additional
		# columns: 'Master' 'virbr0'
		# So if we see Master IN COLUMN 8 then bump everything over two
		# This sucks
		MASTER_CHECK=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $8}' | grep -F "master" | wc -l)

		# Added for checking 2013.1129, remove this later
		if [[ $DEBUG == "yes" ]]
		then
			echo "MASTER is $MASTER_CHECK"
		fi

		if [[ $MASTER_CHECK == 1 ]]
		then
			# Capture the value of the 'master' parameter
			MASTER_NIC=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $9}')

			# Added for checking 2013.1129, remove this later
			if [[ $DEBUG == "yes" ]]
			then
				echo "MASTER_CHECK is $MASTER_CHECK and the nic master is $MASTER_NIC"
			fi

			# Now that we've identified the presence of a 'master' column pair
			# and handled that line, cut out the two columns and continue
			IP_LINK_SHOW_OUTPUT=$(echo $IP_LINK_SHOW_OUTPUT | cut -d " " -f 1-7,10-999)

		fi

		# The position of our statistics varies based on whether or not
		# the 'ip' command includes a 'mode' attribute and its value.
		# Let's check to see if it's there and we'll use it for RX and TX data
		MODE_CHECK=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $10}' | grep -F "mode" | wc -l)

		# Added for checking 2013.1129, remove this later
		if [[ $DEBUG == "yes" ]]
		then
			echo "MODE_CHECK is $MODE_CHECK"
		fi

		if [[ $MODE_CHECK -eq 1 ]]
		then
			MODE_VALUE=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $11}')

			# Added for checking 2013.1129, remove this later
			if [[ $DEBUG == "yes" ]]
			then
				echo "MODE_CHECK is $MODE_CHECK and the mode value is $MODE_VALUE"
			fi

			# Now that we've identified the presence of a 'mode' column pair
			# and handled that line, cut out the two columns and continue
			IP_LINK_SHOW_OUTPUT=$(echo $IP_LINK_SHOW_OUTPUT | cut -d " " -f 1-9,12-999)

		fi

		# Capture the number of bytes and packets received on this interface
		let RX_BYTES=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $26}')
		let RX_PACKETS=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $27}')

		# If these weren't set correctly, set them to numeric 0
		RX_BYTES=${RX_BYTES:-"0"}
		RX_PACKETS=${RX_PACKETS:-"0"}

		# Calculate the traffic in MiB and GiB
		let RX_MIB=( RX_BYTES / 1048576)
		let RX_GIB=( RX_BYTES / 1073741824)

		# Default the human readable size we'll report to " "
		RX_HUMAN=" "

		# If we have 1 or more gigabytes, let's use that.
		if [[ $RX_GIB > 1 ]]
		then
			RX_HUMAN="${RX_GIB}"
			RX_HUMAN_TYPE="GiB"
		# Less than 1 gigabyte but more than 1 megabyte, we'll use megabytes
		elif [[ $RX_MIB > 1 ]]
		then
			RX_HUMAN="${RX_MIB}"
			RX_HUMAN_TYPE="MiB"
		# Less than a megabyte? show the raw byte value
		else
			RX_HUMAN="${RX_BYTES}"
			RX_HUMAN_TYPE="B"
		fi

		# Capture the number of bytes and packets transmitted on this interface
		let TX_BYTES=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $41}')
		let TX_PACKETS=$(echo $IP_LINK_SHOW_OUTPUT | awk '{FS=" "; print $42}')

		# If these weren't set correctly, set them to numeric 0
		TX_BYTES=${TX_BYTES:-"0"}
		TX_PACKETS=${TX_PACKETS:-"0"}

		# Calculate the traffic in MiB and GiB let TX_MIB=( TX_BYTES / 1048576)
		let TX_MIB=( TX_BYTES / 1048576)
		let TX_GIB=( TX_BYTES / 1073741824)

		# Default the human readable size we'll report to " "
		TX_HUMAN=" "

		# If we have 1 or more gigabytes, let's use that.
		if [[ $TX_GIB > 1 ]]
		then
			TX_HUMAN="${TX_GIB}"
			TX_HUMAN_TYPE="GiB"
		# Less than 1 gigabyte but more than 1 megabyte, we'll use megabytes
		elif [[ $TX_MIB > 1 ]]
		then
			TX_HUMAN="${TX_MIB}"
			TX_HUMAN_TYPE="MiB"
		# Less than a megabyte? show the raw byte value
		else
			TX_HUMAN="${TX_BYTES}"
			TX_HUMAN_TYPE="B"
		fi

		# We need ethtool to show the link speed and we won't always have this.
		# So default to Unknown
		WIRE_SPEED="Unknown"

		# Attempt to run 'ethtool' to see if it reports an error
		# Do we have it installed? Does it operate properly?
		ethtool $EACH_NIC > /dev/null 2>&1

		# Do we have an error?
		if (( $? == 0 ))
		then
			# No error, try to run ethtool and get the line we need
			# 1: Use 'ethtool' on our deviec
			# 2: Look for the 'Speed' line which contains our wire link speed
			# 3: Return the second parameter which is our wire link speed
			WIRE_SPEED=$( ethtool $EACH_NIC 2>&1 | grep Speed | awk '{FS=":"; print $2}')
			WIRE_SPEED=${WIRE_SPEED:-"-"}
		fi

		# Report this network device's details to the user
		case $NIC_SUMMARY_STYLE in 
			"short") 
				printf "%12s %17s %8s %18s %7s %9s\n" \
							$EACH_NIC $MAC_ADDRESS $LINK_STATE $IP_ADDRESS $MTU $WIRE_SPEED;;
			"traffic") 
				printf "%12s %17s %8s %18s %7s %9s %8s %-3s %8s %-3s\n" \
							$EACH_NIC $MAC_ADDRESS $LINK_STATE $IP_ADDRESS $MTU $WIRE_SPEED $RX_HUMAN $RX_HUMAN_TYPE $TX_HUMAN $TX_HUMAN_TYPE;;
			"ipv6") 
				printf "%12s %17s %8s %18s %40s %8s %9s %8s %-3s %8s %-3s\n" \
							$EACH_NIC $MAC_ADDRESS $LINK_STATE $IP_ADDRESS $IP6_ADDRESS $MTU $WIRE_SPEED $RX_HUMAN $RX_HUMAN_TYPE $TX_HUMAN $TX_HUMAN_TYPE;;
		esac

	done
	# ----- cut here -----

}

#----------------------------------------------------------------------------
#
# Check for Programs Once
#
#----------------------------------------------------------------------------

# Instead of statically associating the availability of programs with
# known distribution and version combinations, check for programs when
# Birdseye runs and dynamically set whether or not this platform
# has the programs we desire to use

# All of the programs listed here are known to be missing on at least
# one of the standard testing platforms.

# Documentation: check_for_program function (above)
# 1. Set FILE_EXISTS to no
# 2. Call check_for_program with the name of the file you question
# 3. Check value of FILE_EXISTS.  Yes, present, no, missing.

FILE_EXISTS="no"
check_for_program dmidecode
AVAILABLE_DMIDECODE=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lshw
AVAILABLE_LSHW=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lsb_release
AVAILABLE_LSB_RELEASE=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program efibootmgr
AVAILABLE_EFI_BOOTMGR=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lsblk
AVAILABLE_LSBLK=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program pvscan
AVAILABLE_PVSCAN=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program chkconfig
AVAILABLE_CHKCONFIG=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program systemctl
AVAILABLE_SYSTEMCTL=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program setserial
AVAILABLE_SETSERIAL=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lsinitrd
AVAILABLE_LSINITRD=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lscpu
AVAILABLE_LSCPU=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program numactl
AVAILABLE_NUMACTL=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program ethtool
AVAILABLE_ETHTOOL=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lsscsi
AVAILABLE_LSSCSI=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program cd-info
AVAILABLE_CDINFO=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program virsh
AVAILABLE_VIRSH=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lsusb
AVAILABLE_LSUSB=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program sensors
AVAILABLE_SENSORS=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program lspci
AVAILABLE_LSPCI=$FILE_EXISTS

FILE_EXISTS="no"
check_for_program facter
AVAILABLE_FACTER=$FILE_EXISTS

# Suse SLES 11 SP3 reports sensors is present even when the binary
# is not because it sees an /etc/sensors.conf file.  This causes
# check for program to return true and an attempt to use sensors later
# fails.  So if we think we might have it, we'll quickly try it and
# change to NO if we can't run it.
if [[ $AVAILABLE_SENSORS ]]
then
	sensors > /dev/null 2>&1
	if (( $? == 0))
	then
		AVAILABLE_SENSORS="yes"
	else
		AVAILABLE_SENSORS="no"
	fi
fi

# This is a special check because the whereis program that
# function check_for_program uses doesn't find it
if [[ -f /usr/bin/lsusb.py ]]
then
	AVAILABLE_LSUSBPY="yes"
else
	AVAILABLE_LSUSBPY="no"
fi

#----------------------------------------------------------------------------
#
# Check to see if programs work.  Failure often means VMs
#
#----------------------------------------------------------------------------

# If we have dmidecode present, let's try to use it.
# If it fails, we're probably in a virtual machine with no real
# hardware to report on and we can't use it.
# 2013.1014 RHEL 6.4 on Amazon AMI reports:
# 'No SMBIOS nor DMI entry point found, sorry.'
# So we'll check for part of that and see how it goes - Maxwell
DMIDECODE_WORKS="no"
if [[ $AVAILABLE_DMIDECODE == "yes" ]]
then
	# Virtual machine = "No SMIBIOS"
	# Google Compute Engine container = "Operation not permitted"
	if [[ $(dmidecode 2>&1 | grep "No SMBIOS nor DMI" | wc -l) -gt 0 ]] || 
		 [[ $(dmidecode 2>&1 | grep "Operation not permitted" | wc -l) -gt 0 ]]
	then
		DMIDECODE_WORKS="no"
	else
		DMIDECODE_WORKS="yes"
	fi
fi

# 2013.1014 RHEL 6.4 on Amazon AMI reports:
# 'unable to initialize libusb: -99'
# So we'll check for that and avoid USB stuff if we find it.
# Hard to think of any non-virtual machine that doesn't have USB hw
LSUSB_WORKS="no"
if [[ $AVAILABLE_LSUSB == "yes" ]]
then
	if [[ $(lsusb | grep "unable to initialize libusb" | wc -l) -gt 0 ]]
	then
		LSUSB_WORKS="no"
	else
		LSUSB_WORKS="yes"
	fi
fi

# These lack 'dmesg --notime':
# RHEL 6.X, SLES 11 SP3
# Attempt to perform dmesg using --notime to see if we have this feature
FEATURE_DMESG_NOTIME="null"
dmesg --notime >> /dev/null 2>&1
if (( $? == 0 ))
then
	# Error code 0 means we have this feature, hooray!
	FEATURE_DMESG_NOTIME="yes"
else
	# Error code > 0 means we don't have this feature, boo!
	FEATURE_DMESG_NOTIME="no"
fi

# RHEL 6.X: dmesg lacks --ctime option
# Attempt to perform dmesg using --ctime to see if we have this feature
FEATURE_DMESG_CTIME="null"
dmesg --ctime >> /dev/null 2>&1
if (( $? == 0 ))
then
	# Error code 0 means we have this feature, hooray!
	FEATURE_DMESG_CTIME="yes"
else
	# Error code > 0 means we don't have this feature, boo!
	FEATURE_DMESG_CTIME="no"
fi

LSMOD_WORKS="no"
# this check is really just for consistency with how other programs are treated
if [[ $AVAILABLE_LSMOD == "yes" ]]
then

	# Google Compute Engine (containers?) fails with a long error including 'could not open'
	if [[ $(lsmod 2>&1 | grep "could not open" | wc -l) -gt 0 ]]
	then
		LSMOD_WORKS="no"
	else
		LSMOD_WORKS="yes"
	fi

else
	LSMOD_WORKS="no"
fi

#----------------------------------------------------------------------------
#
# Default Variable Handling
#
#----------------------------------------------------------------------------

# BIRDSEYE_ variables listed here are set to default values
# If a config file is found, any or all of these values may be
# overwritten.  Later code references these values regardless
# of whether their values come from these settings or an
# external configuration file.

# HEADER INFORMATION FOR TOP OF REPORT
# filename tag
export BIRDSEYE_TAG=""
# username
export BIRDSEYE_NAME=""
# user's email
export BIRDSEYE_EMAIL=""
# user's group/team/association
export BIRDSEYE_GROUP=""
# the focus of this report: defect, issue, etc.
export BIRDSEYE_FOCUS=""
# user's notes on the HW configuration of the system being reported
export BIRDSEYE_HW_NOTES=""
# user's notes on the SW configuration of the system being reported
export BIRDSEYE_SW_NOTES=""
# host's FQDN
export BIRDSEYE_FQDN="null"
# host's out of bands FQDN (HP iLO, Dell DRAC, MP port, etc)
export BIRDSEYE_OOB="null"

# These variables used in producing output filenames
export BIRDSEYE_FILENAME_YEAR="yes"
export BIRDSEYE_FILENAME_MONTH="yes"
export BIRDSEYE_FILENAME_TIME="no"
export BIRDSEYE_FILENAME_HOST="no"
export BIRDSEYE_FILENAME_TAG="yes"

# Controls whether we will overwrite and existing report
export BIRDSEYE_OUTPUT_FORCE="no"
# Controls whether we show security-related IP and firewall info
export BIRDSEYE_PUBLIC_REPORT="no"
# Controls whether we ask user header questions or just run
export BIRDSEYE_PROMPT_USER="yes"
# Specifies an external CSS style sheet file from the user
export BIRDSEYE_CSS_FILE="null"
# Nice idea, but we can't attach to another X display.. yet?
export BIRDSEYE_XDISPLAY="null"

# Report on Virtualization Details?
export BIRDSEYE_SHOW_VIRT="yes"

# If a config file exists in the user's home directory, execute
# it to set BIRDSEYE_ variables and perform any user supplied processing
if [ -f $HOME/.birdseye.cfg ]
then
	echo "Using in $HOME/.birdseye.cfg:"
	. $HOME/.birdseye.cfg

	echo "Tag       $BIRDSEYE_TAG"
	echo "Name      $BIRDSEYE_NAME"
	echo "Email     $BIRDSEYE_EMAIL"
	echo "Group     $BIRDSEYE_GROUP"
	echo "Focus     $BIRDSEYE_FOCUS"
	echo "HW Notes  $BIRDSEYE_HW_NOTES"
	echo "SW Notes  $BIRDSEYE_SW_NOTES"
	echo
fi

# DEF_ variable are used later in processing the report
# Values are set to one of three sources:
# 1. The 'export BIRDSEYE_' lines above (empty values)
# 2. BIRDSEYE variable definitions in a user's .birdseye.cfg file
# 3. Default values set here
# In most cases, there is no config file, so these defaults are used.

DEF_TAG=${BIRDSEYE_TAG:-"birdseye"}
DEF_NAME=${BIRDSEYE_NAME:-"Not specified"}
DEF_EMAIL=${BIRDSEYE_EMAIL:-"Not specified"}
DEF_GROUP=${BIRDSEYE_GROUP:-"Not specified"}
DEF_FOCUS=${BIRDSEYE_FOCUS:-"Not specified"}
DEF_HW_NOTES=${BIRDSEYE_HW_NOTES:-"Not specified"}
DEF_SW_NOTES=${BIRDSEYE_SW_NOTES:-"Not specified"}

DEF_CSS_FILE=${BIRDSEYE_CSS_FILE:-"internal"}
DEF_CSS_STYLE=${BIRDSEYE_CSS_STYLE:-"default"}

# Nice idea, but we can't attach to another X display.. yet?
DEF_XDISPLAY=${BIRDSEYE_XDISPLAY:-"null"}

DEF_FQDN=${BIRDSEYE_FQDN:-"null"}
if [[ $DEF_FQDN == "null" ]]
then
	DEF_FQDN=$(hostname --fqdn)
fi
DEF_OOB=${BIRDSEYE_OOB:-"null"}

PUBLIC_REPORT=$BIRDSEYE_PUBLIC_REPORT
PROMPT_USER=$BIRDSEYE_PROMPT_USER

# default options for output filename.
# Use options from config file if possible (see above)
FILENAME_YEAR=$BIRDSEYE_FILENAME_YEAR
FILENAME_MONTH=$BIRDSEYE_FILENAME_MONTH
FILENAME_TIME=$BIRDSEYE_FILENAME_TIME
FILENAME_HOST=$BIRDSEYE_FILENAME_HOST
FILENAME_TAG=$BIRDSEYE_FILENAME_TAG

OUTPUT_FORCE=$BIRDSEYE_OUTPUT_FORCE

# Report on Virtualization Details?
DEF_SHOW_VIRT=$BIRDSEYE_SHOW_VIRT

# Use Farenheit instead of the default Celsius readings for sensors?
USE_FARENHEIT=" -f "

#----------------------------------------------------------------------------
#
# Command Line Syntax
#
#----------------------------------------------------------------------------

# Display syntax
function usage {
	echo "Birdseye (version $VERSION)"
	echo
	echo "usage: birdseye <options>"
	echo
	echo "-h --help     Display this syntax information"
	echo
	echo "-p --public   Produce a secure report with no IP network or firewall info."
	echo "-q --quick    Don't prompt the user for tag and title information."
	echo "-d --debug    Enable debugging output."
	echo
	echo "-t --tag      Specify a tag to be included in the filename. 'rhel73' 'vers5hw'"
	echo "-n --name     Specify the name of the user producing this report. 'Lloyd Dobler'"
	echo "-e --email    Specify the email address of the user producing this report."
	echo "-g --group    Specify the group this report is associated with. 'Triage'"
	echo "-i --issue    Specify an issue being investigated. 'Network Fault'"
	echo "   --hwnotes  Specify a note about this hardware config. '1/2 cpus diabled'"
	echo
	echo "-o --oob      Specify a FQDN for this system's out-of-band management NIC"
	echo "-f --fqdn     Specify a FQDN for this system's primary NIC"
	echo
	echo "-c --css      Use an external CSS style file's contents '/home/user/style.css'"
	echo "   --csstype  Use the alternate 'typewriter' CSS style for output"
	echo
	echo "   --celsius  Use Celsius instead of Farenheit readings for sensors"
	echo
	echo "   --novirt   Skip the sections related to Virtualization"
	echo
	echo "   --date     Include year and month in filename"
	echo "   --dt       Include year and month and 24-hour time in filename"
	echo
	echo "   --year     Include year in filename"
	echo "   --month    Include month & day in filename"
	echo "   --time     Include 24-hour format time in filename"
	echo "   --host     Include system's hostname in filename"
	echo "   --notag    Do not include report tag in filename (Default: include)"
	echo "   --force    Overwrite an existing output directory if it exists."
	echo
}

#----------------------------------------------------------------------------
#
# Command Line Options Processing
#
#----------------------------------------------------------------------------

while [ "$1" != "" ]
do

	# Process the next command line argument
	case $1 in 

		# Examine $1 for a command line parameter
		# If the parameter is identified set a value to be used later
		# If the parameter requires an option, 'shift' so $1 is the option
		# Process the option
		# After this case block, shift again so the next parameter is $1

		# enable debugging output
		-d | --debug )
			DEBUG="yes";;

		# produce a report without IP and firewall information 
		# that might lead to intrusion
		-p | --public )
			PUBLIC_REPORT="yes";;

		# don't prompt the user for information, just run it using defaults
		-q | --quick )
			PROMPT_USER="no";;

		# don't prompt the user for information, just run it using defaults
		--celsius)
			USE_FARENHEIT="";; # Changes " -f " to "" and uses sensors default

		# Include 24-hour format time in output filename
		--time )
			FILENAME_TIME="yes";;

		# Same as --month and --year : include date - convenience
		--date )
			FILENAME_YEAR="yes"
			FILENAME_MONTH="yes";;

		# Same as --month and --year : include date - convenience
		--dt )
			FILENAME_TIME="yes"
			FILENAME_YEAR="yes"
			FILENAME_MONTH="yes";;

		# Include YYYY format date in output filename
		--year )
			FILENAME_YEAR="yes";;

		# Include MMDD format date in output filename
		--month )
			FILENAME_MONTH="yes";;

		# Include hostname in output filename
		--host )
			FILENAME_HOST="yes";;

		# Don't include the tag in the output file
		--notag )
			FILENAME_TAG="no";;

		# Include hostname in output filename
		--force )
			OUTPUT_FORCE="yes";;

		# command line parameter: specify external CSS style file
		--novirt )
			DEF_SHOW_VIRT="no";;

		# command line parameter: specify the output tag
		-t | --tag )
			shift
			DEF_TAG=$1;;

		# command line parameter: specify user's name in quotes
		-n | --name )
			shift
			DEF_NAME=$1;;

		# command line parameter: specify the user's email address
		-e | --email )
			shift
			DEF_EMAIL=$1;;

		# command line parameter: specify the user's group or team
		-g | --group )
			shift
			DEF_GROUP=$1;;

		# command line parameter: specify the issue being investigated
		-i | --issue )
			shift
			DEF_FOCUS=$1;;

		# command line parameter: specify notes on the hw configuration
		--hwnotes )
			shift
			DEF_HW_NOTES=$1;;

		# command line parameter: specify notes on the hw configuration
		--swnotes )
			shift
			DEF_SW_NOTES=$1;;

		# command line parameter: future option, specify output filename
		-o | --output )
			shift
			DEF_OUTPUT=$1;;

		# command line parameter: specify a FQDN primary NIC address
		-f | --fqdn )
			shift
			DEF_FQDN=$1;;

		# command line parameter: specify a FQDN oob (iLO) address
		-o | --oob )
			shift
			DEF_OOB=$1;;

		# command line parameter: specify external CSS style file
		-c | --css )
			shift
			DEF_CSS_FILE=$1;;

		# command line parameter: specify external CSS style file
		--csstype )
			shift
			DEF_CSS_STYLE="typewriter";;

		# Provide the user with help
		-h | --help )
		usage
		exit 0;;

		# Something we don't understand? show syntax and exit
		* )
		usage
		exit 1;;
	esac
	shift
done

#----------------------------------------------------------------------------
#
# Debugging: Report DEF_ values here before more processing
#
#----------------------------------------------------------------------------

# If the DEBUG option was set, let's report some basic values here.
if [[ $DEBUG == "yes" ]]
then
	echo "Values after parameter processing:"
	echo
	echo "DEF_TAG $DEF_TAG"
	echo "DEF_NAME $DEF_NAME"
	echo "DEF_EMAIL $DEF_EMAIL"
	echo "DEF_GROUP $DEF_GROUP"
	echo "DEF_FOCUS $DEF_FOCUS"
	echo "DEF_HW_NOTES $DEF_HW_NOTES"
	echo "DEF_SW_NOTES $DEF_SW_NOTES"
	echo "DEF_FQDN $DEF_FQDN"
	echo "DEF_OOB $DEF_OOB"
	echo
	echo "PUBLIC_REPORT $PUBLIC_REPORT"
	echo "PROMPT_USER $PROMPT_USER"
	echo "DEF_OUTPUT $DEF_OUTPUT"
	echo "DEF_CSS_FILE $DEF_CSS_FILE"
	echo "DEF_CSS_STYLE $DEF_CSS_STYLE"
	echo
fi

#----------------------------------------------------------------------------
#
# Interactive Questions for Report Header
#
#----------------------------------------------------------------------------

if [[ $PROMPT_USER == "no" ]]
then
	# set the working variables to the defaults
	MY_TAG=${DEF_TAG:-"null"}
	MY_NAME=${DEF_NAME:-"null"}
	MY_EMAIL=${DEF_EMAIL:-"null"}
	MY_GROUP=${DEF_GROUP:-"null"}
	MY_FOCUS=${DEF_FOCUS:-"null"}
	MY_FQDN=${DEF_FQDN:-"null"}
	MY_OOB=${DEF_OOB:-"null"}
	MY_HW_NOTES=${DEF_HW_NOTES:-"null"}
	MY_SW_NOTES=${DEF_SW_NOTES:-"null"}
else

  echo
	echo "Birdseye Linux Environment Reporting Script"
	echo
	echo "Answers to the following questions are used in Birdseye's"
	echo "HTML report to title and document the system being reported."
	echo
  echo "Specify a 'report-tag' and it will be used to generate unique"
  echo "output filenames to help identify each Birdseye report"
  echo
  echo "Example: birdseye.yyyy.mmdd.MY-REPORT-TAG.html"
	echo
	echo "All other questions are optional and can be skipped by hitting ENTER."
	echo

	####################
	echo -e "\n(1/9) Provide a unique report-tag to include [$DEF_TAG] ?"
	read -p "->" MY_TAG

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_TAG=${MY_TAG:-"null"}

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [[ "$MY_TAG" != "null" ]] && [[ X"$MY_TAG" != X ]]
	then

		# Make this tag command line friendly by removing spaces
		MY_TAG=${MY_TAG//[[:space:]]/}

	else	
		# Make this tag command line friendly by removing spaces
		MY_TAG=${DEF_TAG//[[:space:]]/}
	fi

	####################
	echo -e "\n(2/9) What's your name [$DEF_NAME] ?" 
	read -p "->" MY_NAME

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_NAME=${MY_NAME:-"null"}

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_NAME" != "null" ]
	then
		# redundant - this block is a template for future processing 

		# quote required - spaces will be included!
		MY_NAME="$MY_NAME"
	else	
		# quote required - spaces will be included!
		MY_NAME="$DEF_NAME"
	fi

	####################
	echo -e "\n(3/9) What's your email address [$DEF_EMAIL] ?" 
	read -p "->" MY_EMAIL

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_EMAIL=${MY_EMAIL:-"null"}

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_EMAIL" != "null" ]
	then
		# redundant - this block is a template for future processing 

		# quote required - spaces will be included!
		MY_EMAIL="$MY_EMAIL"
	else	
		# quote required - spaces will be included!
		MY_EMAIL="$DEF_EMAIL"
	fi

	####################
	echo -e "\n(4/9) What group/company/org are you in ('devops') [$DEF_GROUP] ?"
	read -p "->" MY_GROUP

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_GROUP=${MY_GROUP:-"null"}

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_GROUP" != "null" ]
	then
		# redundant - this block is a template for future processing 

		MY_GROUP="$MY_GROUP"
	else	
		MY_GROUP="$DEF_GROUP"
	fi

	####################
	echo -e "\n(5/9) A simple description for the issue being reported [$DEF_FOCUS] ?"
	read -p "->" MY_FOCUS

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_FOCUS="${MY_FOCUS:-"null"}"

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_FOCUS" != "null" ]
	then
		# redundant - this block is a template for future processing 

		# quote required - spaces will be included!
		MY_FOCUS="$MY_FOCUS"
	else	
		# quote required - spaces will be included!
		MY_FOCUS=$DEF_FOCUS
	fi

	####################
	echo -e "\n(6/9) Notes about the system hardware configuration? [$DEF_HW_NOTES]"
	read -p "->" MY_HW_NOTES

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_HW_NOTES="${MY_HW_NOTES:-"null"}"

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_HW_NOTES" != "null" ]
	then
		# quote required - spaces will be included!
		MY_HW_NOTES="$MY_HW_NOTES"
	else	
		# quote required - spaces will be included!
		MY_HW_NOTES="$DEF_HW_NOTES"
	fi

	####################
	echo -e "\n(7/9) Notes about the system software configuration? [$DEF_SW_NOTES]"
	read -p "->" MY_SW_NOTES

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_SW_NOTES="${MY_SW_NOTES:-"null"}"

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_SW_NOTES" != "null" ]
	then
		# quote required - spaces will be included!
		MY_SW_NOTES="$MY_SW_NOTES"
	else	
		# quote required - spaces will be included!
		MY_SW_NOTES="$DEF_SW_NOTES"
	fi

	####################
	echo -e "\n(8/9) What is the FQDN for this systems primary NIC? [$DEF_FQDN]"
	read -p "->" MY_FQDN

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_FQDN="${MY_FQDN:-"null"}"

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_FQDN" != "null" ]
	then
		# quote required - spaces will be included!
		MY_FQDN="$MY_FQDN"
	else	
		# quote required - spaces will be included!
		MY_FQDN="$DEF_FQDN"
	fi

	####################
	echo -e "\n(9/9) What is the FQDN for this systems out-of-band mgmt NIC? [$DEF_OOB]"
	read -p "->" MY_OOB

	# Keep a valid, non-null user supplied value or set it to "null"
	MY_OOB="${MY_OOB:-"null"}"

	# If the user value is not "null" and not "" then process it
	# otherwise, set it to the DEF_TAG value set earlier in the script
	if [ "$MY_OOB" != "null" ]
	then
		# quote required - spaces will be included!
		MY_OOB="$MY_OOB"
	else	
		# quote required - spaces will be included!
		MY_OOB="$DEF_OOB"
	fi

fi

#----------------------------------------------------------------------------
#
# Clean Up Interactive Answers
#
#----------------------------------------------------------------------------

# If we don't have http on the front of the OOB FQDN, add it.
# Without http:// clicking in this link takes users to a file
if [[ $MY_OOB != "null" && ${MY_OOB:1:7} != "http://" ]]
then
	MY_OOB="http://$MY_OOB/"
fi

#----------------------------------------------------------------------------
#
# Debugging: Report Working "MY_" Variables here
#
#----------------------------------------------------------------------------

if [[ $DEBUG == "yes" ]]
then
	echo "Values after interactive prompting:"
	echo
	echo "MY_TAG $MY_TAG"
	echo "MY_NAME $MY_NAME"
	echo "MY_EMAIL $MY_EMAIL"
	echo "MY_GROUP $MY_GROUP"
	echo "MY_FOCUS $MY_FOCUS"
	echo "MY_HW_NOTES $MY_HW_NOTES"
	echo "MY_SW_NOTES $MY_SW_NOTES"
	echo "MY_FQDN $MY_FQDN"
	echo "MY_OOB $MY_OOB"
	echo
fi

#----------------------------------------------------------------------------
#
# Construct output filename using command line options
#
#----------------------------------------------------------------------------

# fast, FQDN?
MY_HOST=$HOSTNAME

# Default prefix for all output filenames
FILENAME_DATA="birdseye"

if [[ $DEBUG == "yes" ]]
then
	echo "Output filename processing:"
	echo
	echo "FILENAME_HOST  $FILENAME_HOST"
	echo "FILENAME_TAG   $FILENAME_TAG"
	echo "FILENAME_YEAR  $FILENAME_YEAR"
	echo "FILENAME_MONTH $FILENAME_MONTH"
	echo "FILENAME_TIME  $FILENAME_TIME"
fi

# Append year ("YYYY" format) to filename?
if [[ $FILENAME_YEAR == "yes" ]]
then
	FILENAME_DATA=$FILENAME_DATA.$(date +%Y)
fi

# Append month-day ("MMDD" format) to filename?
if [[ $FILENAME_MONTH == "yes" ]]
then
	FILENAME_DATA=$FILENAME_DATA.$(date +%m%d)
fi

# Append 24-hour time ("HHMM" format) to filename?
if [[ $FILENAME_TIME == "yes" ]]
then
	FILENAME_DATA=$FILENAME_DATA.$(date +%H%M)
fi

# Append hostname to filename ?
if [[ $FILENAME_HOST == "yes" ]]
then
	FILENAME_DATA=$FILENAME_DATA.$MY_HOST
fi

# Append the user's tag to the filename?
if [[ $FILENAME_TAG == "yes" ]]
then
	FILENAME_DATA="$FILENAME_DATA.$MY_TAG"
fi

# Set the working variable for the output directory to our constructed 
# output filename template
export OUTPUT_DIR="$FILENAME_DATA"

# Does the output directory exist? 
if [[ -d "$OUTPUT_DIR" ]]
then
	# If we haven't been told to force it, don't overwrite what might
	# be important existing data that can't be recreated
	if [[ $OUTPUT_FORCE == "no" ]]
	then
		echo
		echo "Directory $OUTPUT_DIR exists. Please remove or use --force"
		exit
	else
		echo
		echo "Directory $OUTPUT_DIR exists, using --force to replace it."
		# I'm paranoid about using 'rm -f' with a variable (especially as 
		# root) So we'll keep the existing directory and remove only the
		# old files that might conflict with THIS report.
		# Other files in the existing directory are kept 

		rm -f $OUTPUT_DIR/*.txt birdseye.$FILENAME_DATA.tar birdseye.$FILENAME_DATA.tar.gz
	fi
else # Our output directory does NOT exist

	# Let's try to make a new output directory
	mkdir "$OUTPUT_DIR"

	# Did we succeed?
	if [ $? != 0 ]
	then
		echo "Error: I can't create directory $OUTPUT_DIR"
		exit
	fi
fi

# HTML is the name of our often used HTML format output file
HTML="$OUTPUT_DIR/$FILENAME_DATA.html"

if [[ $DEBUG == "yes" ]]
then
	echo "Construct Output: OUTPUT_DIR $OUTPUT_DIR"
fi

# These additional ASCII files contain raw output and many users
# wish to have them seperate for processing with 'grep' and other
# programs.
FILE_DMI="$OUTPUT_DIR/dmidecode.$FILENAME_DATA.txt"
FILE_CPU="$OUTPUT_DIR/cpuinfo.$FILENAME_DATA.txt"
FILE_MSGS="$OUTPUT_DIR/messages.$FILENAME_DATA.txt"
FILE_SYSLOG="$OUTPUT_DIR/syslog.$FILENAME_DATA.txt"
FILE_DMESG="$OUTPUT_DIR/dmesg.$FILENAME_DATA.txt"
FILE_DMESG_NOTIME="$OUTPUT_DIR/dmesg-notime.$FILENAME_DATA.txt"
FILE_INTER="$OUTPUT_DIR/interrupts.$FILENAME_DATA.txt"
FILE_PCI="$OUTPUT_DIR/lspci.$FILENAME_DATA.txt"
FILE_INITRD="$OUTPUT_DIR/initrd.$FILENAME_DATA.txt"

#----------------------------------------------------------------------------
#
# Traps for CONTROL-C interruption by user
#
#----------------------------------------------------------------------------

function trap_cleanup {

	echo "Trap caught, cleaning up.."

	if [[ -f "$OUTPUT_DIR" ]]
	then	
		rm -r "$OUTPUT_DIR"
	fi

	if [[ -f "$OUTPUT_DIR.tar" ]]
	then	
		rm -f "$OUTPUT_DIR.tar"
	fi

	if [[ -f "$OUTPUT_DIR.tar.gz" ]]
	then	
		rm -f "$OUTPUT_DIR.tar.gz"
	fi

	exit 255
}

trap 'trap_cleanup; exit 255' SIGINT SIGQUIT SIGTERM

#----------------------------------------------------------------------------
#
# Empty the contents of each file before writing new data
#
# Originally this was used to place a header on each file
# Emptying files now allows ALL future work to be a simple
# append output to each file
#----------------------------------------------------------------------------

for EACH_FILE in \
	$HTML $FILE_DMI $FILE_CPU $FILE_MSGS $FILE_DMESG $FILE_DMESG_NOTIME \
	$FILE_INTER $FILE_PCI $FILE_INITRD
do
	echo -n > $EACH_FILE
done

#----------------------------------------------------------------------------
# QUIRKS
#
# 1) Set defaults here
# 2) Adjust them for the distribution running
# 3) Use them later when trying to execute commands
#----------------------------------------------------------------------------

QUIRK_LSCPU="null"
QUIRK_VIRSH_DOMSTATE="null"
QUIRK_VIRSH_DESC="null"

#----------------------------------------------------------------------------
#
# GLOBAL VARS (GENERAL)
#
#----------------------------------------------------------------------------

# Used by the functions text_open and text_close
# Set by text_open to record the type of raw output text box opened
# Used by text_close to perform the matching close operation
_LAST_TEXT_OPEN="none"

#----------------------------------------------------------------------------
#
# Identify our distribution and version
#
# Set values that make a Distribution+Version unique here
#
#----------------------------------------------------------------------------

# Distribution: fedora, redhat, oracle, centos, suse, ubuntu, debian
# Used to identify the distribution
DIST_NAME="null"

# Release version "5", "6", "7"
# Used to identify and handle quirks associated with a major release cycle
DIST_VERSION_ID="null"

# FUTURE: Release minor version -- We don't use this yet 2013.06.19
# Used to identify and handle quirks associated with a minor release cycle
DIST_VERSION_ID_MINOR="null"

# Release Family: "redhat" = (redhat, oracle, centos)
# Used to identify and handle quirks with a common set (fedora+centos+redhat)
# of distributions.  Combine with DIST_VERSION_ID for granularity
DIST_FAMILY="null"

# Used to identify the type of packaging tools used: rpm, dpkg, zypper
DIST_PACKAGES="null"

# Grub configuration file used by distribution+version
# Used to identfy this distribution+version's grub configuration file name
DIST_GRUB_CONF="grub.cfg"

# Used to identfy this distribution+version's grub configuration file name
# Set to /boot/grub default then modify as we identify changes 
# EFI systems may place their files in /boot/efi/efi/Distribution/
# so we'll have to process this some later.
DIST_BOOT_CFG="/boot/grub"

# Does this system use sysconfig for common configuration files
# such as networking interfaces?
DIST_SYSCONFIG="no"

#----------------------------------------------------------------------------
# 
# Identify Distribution and Version using standard /etc/os-release file
#
#----------------------------------------------------------------------------

# Fedora contains fedora-release and redhat-release
# Oracle main contain oracle-release and redhat-release as well
#
# So, look for fedora first, set it and skip the others if found
# If not fedora, check for oracle, then redhat and others

# Try to use an /etc/os-release file to identify this release
if [[ -f /etc/os-release ]]
then
	# 1: Use file /etc/os-release as source
	# 2: Find the line that starts with NAME=
	# 3: Return the second parameter of that line
	# 4: Remove quotes around the value
	DIST_NAME=$(cat /etc/os-release | grep "^NAME=" | awk -F "=" '{print $2}' | sed "s/\"//g" )

	# 1: Use file /etc/os-release as source
	# 2: Find the line that starts with VERSION_ID=
	# 3: Return the second parameter of that line
	# 4: Remove quotes around the value
	DIST_VERSION_ID=$(cat /etc/os-release | grep "^VERSION_ID=" | awk -F "=" '{print $2}' | sed "s/\"//g" )

	# 1: Use file /etc/os-release as source
	# 2: Find the line that starts with PRETTY_NAME=
	# 3: Return the second parameter of that line
	# 4: Remove quotes around the value
	DIST_PRETTY_NAME=$(cat /etc/os-release | grep "^PRETTY_NAME=" | awk -F "=" '{print $2}' | sed "s/\"//g" )
fi

# Let's shorten this for simplicity later
if [[ $DIST_NAME == "Debian GNU/Linux" ]]
then
	DIST_NAME="Debian"
fi

#----------------------------------------------------------------------------
# 
# Identify Distribution and Version using methods OTHER THAN /etc/os-release
#
#----------------------------------------------------------------------------

if [[ $DIST_NAME == "null" ]]
then

	# No /etc/os-release for 
	# - Suse SLES 11 SP3
	# - Red Hat 6.4
	# - Amazon AWS Linux AMI 2013.09

	if [[ -f /etc/SuSE-release ]]
	then

		DIST_NAME="Suse"
		DIST_PRETTY_NAME=$(cat /etc/SuSE-release | head -1)

		DIST_VERSION_ID=$(cat /etc/SuSE-release | grep "^VERSION =")
		DIST_VERSION_ID=${DIST_VERSION_ID##VERSION = }

		DIST_VERSION_ID_MINOR=$(cat /etc/SuSE-release | grep "^PATCHLEVEL = ")
		DIST_VERSION_ID_MINOR=${DIST_VERSION_ID_MINOR##PATCHLEVEL = }

	elif [[ -f /etc/fedora-release ]]
	then
		# This stub is for older fedora releases which may not have
		# /etc/os-release.  Newer systems won't use this.

		DIST_NAME="Fedora"
		DIST_PRETTY_NAME=$(cat /etc/redhat-release | head -1)

		# Warning: positional, this might change and needs to be
		# made more flexible.  Search for "." and use that?
		DIST_VERSION_ID=$(cat /etc/redhat-release | awk -F " " '{ print $3 }')

		DIST_VERSION_ID=${DIST_VERSION_ID%%.*}

		#DIST_VERSION_ID_MINOR is not used in fedora.
	elif [[ -f /etc/redhat-release ]]
	then

		# Citrix XenServer is based on an old Red Hat foundation
		# as a result, they have things like /etc/redhat-release
		# present but containing a XenServer identification string
		# so we need to check for XenServer here and handle it.  Messy
		if [[ $(cat /etc/redhat-release | grep XenServer | wc -l) -gt 0 ]]
		then

			DIST_NAME="Citrix"
			DIST_PRETTY_NAME=$(cat /etc/redhat-release | head -1)

			# Example:
			# "XenServer release 6.1.0-59235p (xenenterprise)"
			DIST_VERSION_ID=$(cat /etc/redhat-release)

			# Convert 6.1.0-59235p
			DIST_VERSION_ID=${DIST_VERSION_ID##XenServer release }
			DIST_VERSION_ID=${DIST_VERSION_ID%%.*}

		else

			DIST_NAME="Redhat"
			DIST_PRETTY_NAME=$(cat /etc/redhat-release | head -1)

			# Warning: positional, this might change and needs to be
			# made more flexible.  Search for "." and use that?
			DIST_VERSION_ID=$(cat /etc/redhat-release | awk -F " " '{ print $7 }')
			DIST_VERSION_ID_MINOR=$(cat /etc/redhat-release | awk -F " " '{ print $7 }')

			# Convert 6.4 to 6
			DIST_VERSION_ID=${DIST_VERSION_ID%%.*}

			# Convert 6.4 to 4
			DIST_VERSION_ID_MINOR=${DIST_VERSION_ID_MINOR##*.}
		fi
	elif [[ -f /etc/image-id ]]
	then

		if [[ $(grep -F "recipe_name=\"amzn ami\"" /etc/image-id | wc -l) -gt 0 ]]
		then

			DIST_NAME="AmazonAWSLinux"
			DIST_PRETTY_NAME=$(cat /etc/system-release | head -1)

			# Warning: positional, this might change and needs to be
			# made more flexible.  Search for "." and use that?
			DIST_VERSION_ID=$(grep -F "image_version=" /etc/image-id | awk -F "=" '{print $2}' | sed "s/\"//g")
			DIST_VERSION_ID_MINOR=$(grep -F "image_version=" /etc/image-id | awk -F "=" '{print $2}' | sed "s/\"//g")

			# Convert 2013.09 to 2013
			#DIST_VERSION_ID=${DIST_VERSION_ID%%.*}

			# Convert 2013.09 to 09
			DIST_VERSION_ID_MINOR=${DIST_VERSION_ID_MINOR##*.}
		fi

	fi # endif - checking for /etc/<dist-release> files when os-release fails

fi

if [[ $DEBUG == "yes" ]]
then
	echo "DEBUG After os-release/system-release/image-id"
	echo "DEBUG DIST_VERSION_ID $DIST_VERSION_ID"
	echo "DEBUG DIST_VERSION_ID_MINOR $DIST_VERSION_ID_MINOR"
fi

#----------------------------------------------------------------------------

if [[ $DIST_NAME == "Fedora" ]]
then
	DIST_PACKAGES="rpm"
	DIST_FAMILY="Redhat"
	DIST_UEFI_DIR="/boot/efi/EFI/Fedora"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network-scripts"

	# This script only officially supports Fedora 18+ 
	
	if [[ $DIST_VERSION_ID == "18" ]]
	then
		DIST_BOOT_CFG="/boot/grub2"
		DIST_GRUB_CONF="grub.cfg"
	elif [[ $DIST_VERSION_ID == "19" ]]
	then
		DIST_BOOT_CFG="/boot/grub2"
		DIST_GRUB_CONF="grub.cfg"
	fi

elif [[ $DIST_NAME == "Oracle" ]]
then
	DIST_FAMILY="Redhat"
	DIST_PACKAGES="rpm"
	DIST_UEFI_DIR="/boot/efi/EFI/Oracle"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network-scripts"

	if [[ $DIST_VERSION_ID == "5" ]]
	then
		DIST_GRUB_CONF="grub.conf"
		QUIRK_VIRSH_DOMSTATE="no-reason"
		QUIRK_VIRSH_DESC="no-desc"
	elif [[ $DIST_VERSION_ID == "6" ]]
	then
		DIST_GRUB_CONF="grub.conf"
	elif [[ $DIST_VERSION_ID == "7" ]]
	then
		/* expected, not tested 2013.1017.01 maxwell */
		DIST_GRUB_CONF="grub2.conf"
	fi

elif [[ $DIST_NAME == "Centos" ]]
then
	DIST_FAMILY="Redhat"
	DIST_PACKAGES="rpm"
	DIST_UEFI_DIR="/boot/efi/EFI/Centos"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network-scripts"

	if [[ $DIST_VERSION_ID == "5" ]]
	then
		DIST_GRUB_CONF="grub.conf"
		QUIRK_VIRSH_DOMSTATE="no-reason"
		QUIRK_VIRSH_DESC="no-desc"
	elif [[ $DIST_VERSION_ID == "6" ]]
	then
		DIST_GRUB_CONF="grub.conf"
	elif [[ $DIST_VERSION_ID == "7" ]]
	then
		DIST_BOOT_CFG="/boot/grub2"
		DIST_GRUB_CONF="grub.conf"
	fi

elif [[ $DIST_NAME == "Citrix" ]]
then
	DIST_FAMILY="Redhat"
	DIST_PACKAGES="rpm"
	# not tested 2013.1019
	DIST_UEFI_DIR="/boot/efi/EFI/Citrix"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network-scripts"

	if [[ $DIST_VERSION_ID == "5" ]]
	then
		DIST_GRUB_CONF="grub.conf"
		QUIRK_VIRSH_DOMSTATE="no-reason"
		QUIRK_VIRSH_DESC="no-desc"
	elif [[ $DIST_VERSION_ID == "6" ]]
	then
		DIST_GRUB_CONF="grub.conf"
	fi

elif [[ $DIST_NAME == "Redhat" ]]
then
	DIST_FAMILY="Redhat"
	DIST_PACKAGES="rpm"
	DIST_UEFI_DIR="/boot/efi/EFI/Redhat"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network-scripts"

	if [[ $DIST_VERSION_ID == "5" ]]
	then
		DIST_GRUB_CONF="grub.conf"
		QUIRK_VIRSH_DOMSTATE="no-reason"
		QUIRK_VIRSH_DESC="no-desc"
	elif [[ $DIST_VERSION_ID == "6" ]]
	then
		DIST_GRUB_CONF="grub.conf"
	elif [[ $DIST_VERSION_ID == "7" ]]
	then
		DIST_BOOT_CFG="/boot/grub2"
		DIST_GRUB_CONF="grub.conf"
	fi

elif [[ $DIST_NAME == "SuSe" || $DIST_NAME == "Suse" ]]
then
	DIST_FAMILY="Suse"
	DIST_PACKAGES="zypper"
	DIST_UEFI_DIR="/boot/efi/efi/SuSE"
	DIST_SYSCONFIG="yes"
	DIST_SYSCONFIG_NETDIR="/etc/sysconfig/network"

	if [[ $DIST_VERSION_ID == "10" ]]
	then
		# placeholder
		FUTURE_CODE_HERE="yes"
	elif [[ $DIST_VERSION_ID == "11" ]]
	then
		# placeholder
		FUTURE_CODE_HERE="yes"
	elif [[ $DIST_VERSION_ID == "12" ]]
	then
		# placeholder
		FUTURE_CODE_HERE="yes"
	fi

elif [[ $DIST_NAME == "Ubuntu" ]]
then

	DIST_FAMILY="Debian"
	DIST_PACKAGES="dpkg"
	DIST_UEFI_DIR="/boot/efi/efi/Ubuntu"
	DIST_SYSCONFIG="no"

	if [[ $DIST_VERSION_ID == "13.10" || $DIST_VERSION_ID == "13.04" ]]
	then
		QUIRK_LSCPU="noext"
		DIST_BOOT_CFG="/boot/grub"
		DIST_GRUB_CONF="grub.cfg"
	elif [[ $DIST_VERSION_ID == "12.04" || $DIST_VERSION_ID == "12.10" ]]
	then
		QUIRK_LSCPU="noext"
		DIST_BOOT_CFG="/boot/grub"
		DIST_GRUB_CONF="grub.cfg"
	elif [[ $DIST_VERSION_ID == "11.04" || $DIST_VERSION_ID == "11.10" ]]
	then
		QUIRK_LSCPU="noext"
		DIST_BOOT_CFG="/boot/grub"
		DIST_GRUB_CONF="grub.cfg"
	elif [[ $DIST_VERSION_ID == "10.04" || $DIST_VERSION_ID == "10.10" ]]
	then
		QUIRK_LSCPU="noext"
	fi

elif [[ $DIST_NAME == "LinuxMint" || $DIST_NAME == "Linuxmint" ]]
then
	DIST_FAMILY="Debian"
	DIST_PACKAGES="dpkg"
	# not tested - no UEFI hardware :( 2013.1018 maxwell
	DIST_UEFI_DIR="/boot/efi/efi/LinuxMint"
	DIST_SYSCONFIG="no"

	if [[ $DIST_VERSION_ID == "15" ]]
	then
		QUIRK_LSCPU="noext"
	elif [[ $DIST_VERSION_ID == "14" ]]
	then
		QUIRK_LSCPU="noext"
	fi

elif [[ $DIST_NAME == "Debian" ]]
then
	DIST_FAMILY="Debian"
	DIST_PACKAGES="dpkg"
	# not tested - no UEFI hardware :( 2013.1018 maxwell
	DIST_UEFI_DIR="/boot/efi/efi/LinuxMint"
	DIST_SYSCONFIG="no"

	if [[ $DIST_VERSION_ID == "7" ]]
	then
		QUIRK_LSCPU="noext"
	elif [[ $DIST_VERSION_ID == "6" ]]
	then
		QUIRK_LSCPU="noext"
	fi

elif [[ $DIST_NAME == "AmazonAWSLinux" ]]
then
	DIST_FAMILY="Redhat"
	DIST_PACKAGES="rpm"
	# not tested - no UEFI VM :( 2013.1022 maxwell
	# not expected to work either, just a place holder
	DIST_UEFI_DIR="/boot/efi/efi/AmazonAWS"
	DIST_SYSCONFIG="no"

fi

#----------------------------------------------------------------------------
#
# Virtualization Discovery
#
#----------------------------------------------------------------------------

# We default to 'no' until we confirm in some way that we are a Xen Host
# IOW, we're not set to 'null'
XEN_HOST="no"

# Check for xen management 'xm' command (RHEL 5.x, SLES)
FILE_EXISTS="no"
check_for_program xm
if [[ $FILE_EXISTS == "yes" ]]
then
	if [[ $(xm uptime | grep Domain-0 | wc -l ) -eq 1 ]]
	then
		XEN_HOST="yes"
	else
		XEN_HOST="no"
	fi
else

	# Check for xen management 'xe' command (Citrix XenServer)
	FILE_EXISTS="no"
	check_for_program xe
	if [[ $FILE_EXISTS == "yes" ]]
	then
		if [[ $(xe uptime | grep Domain-0 | wc -l ) -eq 1 ]]
		then
			XEN_HOST="yes"
		else
			XEN_HOST="no"
		fi
	fi
fi

# We default to 'no' until we confirm in some way that we are a known VM type
# IOW, we're not set to 'null'
VM_GUEST="no"

# 2013.1014 Testing on the Amazon AWS reveals that lscpu reports
# "Hypervisor vendor" as 'Xen' while reporting Intel chip details.
# This might be a nice way to determine if we're in a VM.
# 2013.1017 Fedora19+QEMU+KVM 'KVM' returned for KVM guests
if [[ $AVAILABLE_LSCPU == "yes" ]]
then
	if [[ $(lscpu | grep "Hypervisor vendor" | grep "Xen" | wc -l) -gt 0 ]]
	then
		VM_GUEST="xen"
	elif [[ $(lscpu | grep "Hypervisor vendor" | grep "KVM" | wc -l) -gt 0 ]]
	then
		VM_GUEST="kvm"
	fi

fi

if [[ $DEBUG == "yes" ]]
then
	echo
	echo "VM Guest Identification: VM_GUEST $VM_GUEST"
fi

#----------------------------------------------------------------------------
#
# Debugging: Report Distribution and Version Results
#
#----------------------------------------------------------------------------
if [[ $DEBUG == "yes" ]]
then
	echo "DIST_NAME $DIST_NAME"
	echo "DIST_VERSION_ID $DIST_VERSION_ID"
	echo "DIST_VERSION_ID_MINOR $DIST_VERSION_ID_MINOR"
	echo "DIST_FAMILY $DIST_FAMILY"
	echo "DIST_PACKAGES $DIST_PACKAGES"
	echo "DIST_GRUB_CONF $DIST_GRUB_CONF"
	echo "DIST_BOOT_CFG $DIST_BOOT_CFG"
	echo
	echo "QUIRK_LSCPU $QUIRK_LSCPU"
	echo "QUIRK_VIRSH_DOMSTATE $QUIRK_VIRSH_DOMSTATE"
	echo "QUIRK_VIRSH_DESC $QUIRK_VIRSH_DESC"
	echo
fi

#----------------------------------------------------------------------------
#
# Let's GO: Produce the HTML Report
#
#----------------------------------------------------------------------------

line "<!doctype html>\n<html>\n<head>\n<title>Birdseye Report for $MY_HOST</title>"
line "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">"

#----------------------------------------------------------------------------
#
# CSS STYLE SHEET for presentation
#
#----------------------------------------------------------------------------

# future option, not tested yet
if [[ $DEF_CSS_FILE != "null" ]] && [ -f "$DEF_CSS_FILE" ]
then
	cat "$DEF_CSS_FILE" >> $HTML
else

	if [[ $DEF_CSS_STYLE == "default" ]]
	then
		cat >> $HTML << CSS-STYLE-SCRIPT-DEFAULT
<style type="text/css">

/*------------------------------------------------------------------------
 * Body - Overall page defaults
 *------------------------------------------------------------------------*/

body {
	/* default font */
	font-family: Lucida, "Myriad Pro", Myriad, Verdana, sans-serif;

	/* default text color */
	color: #000;

	/* default page color */
	background-color: #fff;

	/* provides slight margin space on left and right of whole page */
	margin-left: 25px;
	margin-right: 25px;

	/* font size, adjust to smaller at 93% for alternate look */
	font-size: 100%;
}

/*------------------------------------------------------------------------
 * Paragraphs
 *------------------------------------------------------------------------*/

p {
  line-height: 1.0em;
  font-size: 1.0em;
  margin: 2px 0 8px 0px;
}

.toc_master_paragraph {
  margin-left: 20px;
}

/*------------------------------------------------------------------------
 * Headings
 *------------------------------------------------------------------------*/

/*
	This is an example of how heading styles are used and how they
	are called using bash functions within birdseye

	function      h?  Example             Description
	n/a           h1 "Birdseye Report"    Report Title
	toc_section{} h2 "Hardware Summary"   Titles a section of TOC items
	section{}     h2 "Hardware Summary"   Titles a section of information
	title{}       h3 "Product Name"       Titles a group of related items
	item_title{}    h4 "Product Model"    Title for an item of data

*/

h1, h2, h3, h4, h5, h6 {
	margin: 0 0 3px 0;
}

/* Hovering over the link to the Birdseye Landing page */
h1 a:hover {
  color: #EC5800;
  text-decoration: none;
}

/* Hovering over a heading that links to something */
h2 a:hover,
h3 a:hover,
h4 a:hover {
  color: #666666;
  text-decoration: none;
}

/*------------------------------------------------------------------------
 * Heading: h2: Calls attention to sections of data
 *------------------------------------------------------------------------*/

h1 {
  font-size: 1.5em;
  font-weight: bold;
  color: #3c6eb4;
}

/*------------------------------------------------------------------------
 * Heading: h2: Calls attention to sections of data
 *------------------------------------------------------------------------*/

h2 {
  font-size: 1.3em;
  font-weight: bold;
  color: #3c6eb4;
  text-decoration: underline;
}

/*------------------------------------------------------------------------
 * Heading: h3:
 *------------------------------------------------------------------------*/

/* Used as a title for each item of information being reported */
h3 {
  font-size: 1.05em;
  font-weight: bold;
  color: #3c6eb4; 
}

/* Used to show raw commands in title without the title's bold */
.h3_nobold {
	font-weight: normal;
}

/*------------------------------------------------------------------------
 * Heading: h4:
 *------------------------------------------------------------------------*/

/* Used as a title for each sub-item of information being reported */
h4 {
  font-size: 0.95em;
  font-weight: bold;
}

/* Used to show raw commands in title without the title's bold */
.h4_nobold {
	font-weight: normal;
}

/*------------------------------------------------------------------------
 * Heading: h5:
 *------------------------------------------------------------------------*/

/* Used as a title for each sub-item of information being reported */
h5 {
  font-size: 0.95em;
  font-weight: bold;
  margin: 0px 25px 5px 25px;
}

/* Used to show raw commands in title without the title's bold */
.h5_nobold {
	font-weight: normal;
}


/*------------------------------------------------------------------------
 * Lists
 *------------------------------------------------------------------------*/

/* Used to show raw commands in list items using fixed width fonts */
.list_nobold {
	font-weight: normal;
	font-size: 0.75em;
	font-family: "Andale Mono", "Courier New", "Courier", "Fixed"
}

/*------------------------------------------------------------------------
 * Links
 *------------------------------------------------------------------------*/

a:link      { color:#3c6eb4; text-decoration: none; }
a:visited   { color:#004E66; text-decoration: underline; }
a:active    { color:#3c6eb4; text-decoration: underline; }
a:hover     { color:#000000; text-decoration: underline; }

/* Lists */
ol, ul, li {
  margin: 2px 0 8px 0px;
  line-height: 1.0em;
  font-size: 1.0em;
  margin: 2px 0 8px 0px;
}

/*------------------------------------------------------------------------
 * Pointer to top of page - Replace with cleaner Javascript in future?
 *------------------------------------------------------------------------*/

/* This makes a little box with the word "Top" in it that takes the user
   back to the top of the page */
.boxtop {
	color: #A7ABBE;
  margin: 0px 0px 0px 10px;
}

/* Hovering over the link to the Birdseye Landing page */
.boxtop a:hover {
  color: #EC5800;
  text-decoration: none;
}

/*------------------------------------------------------------------------
 * Raw Output
 *------------------------------------------------------------------------*/

/*
	Raw output data from commands,
	Presented as a box with soft, rounded corners, 3D shadowing, 
	A different background color,
	Uses a fixed width font to preserve raw output column formatting.
*/

.programlisting {

  border-width: 1px;
  border-style: solid;
  border-radius: 8px;
  border-color: #CFCFCF;
  background-color: rgb(238,232,213);
  padding: 12px;
  margin: 0px 25px 20px 25px;
  overflow: auto;

  box-shadow: 3px 3px 5px #DFDFDF;
  -moz-box-shadow: 3px 3px 5px #DFDFDF;
  -webkit-box-shadow: 3px 3px 5px #DFDFDF;
  -khtml-box-shadow: 3px 3px 5px #DFDFDF;
  -o-box-shadow: 3px 3px 5px #DFDFDF;
  -moz-border-radius: 8px;
  -webkit-border-radius: 8px;
  -khtml-border-radius: 8px;
}

.raw_textarea {

  border-width: 1px;
  border-style: solid;
  border-radius: 8px;
  border-color: #CFCFCF;
  background-color: rgb(238,232,213);
  padding: 12px;
  margin: 0px 25px 20px 25px;
  overflow: auto;

  box-shadow: 3px 3px 5px #DFDFDF;
  -moz-box-shadow: 3px 3px 5px #DFDFDF;
  -webkit-box-shadow: 3px 3px 5px #DFDFDF;
  -khtml-box-shadow: 3px 3px 5px #DFDFDF;
  -o-box-shadow: 3px 3px 5px #DFDFDF;
  -moz-border-radius: 8px;
  -webkit-border-radius: 8px;
  -khtml-border-radius: 8px;
}

/*------------------------------------------------------------------------
 * Tips
 *------------------------------------------------------------------------*/

blockquote.tip {

  background-color: #F5F298;
  color: black;

  border-width: 1px;
  border-style: solid;
  border-color: #DBDBCC;

  padding: 12px;
  margin: 0px 25px 20px 25px;
	width: 55%;

  overflow: auto;
  -moz-border-radius: 8px;
  -webkit-border-radius: 8px;
  -khtml-border-radius: 8px;
  border-radius: 8px;

  -moz-box-shadow: 3px 3px 5px #DFDFDF;
  -webkit-box-shadow: 3px 3px 5px #DFDFDF;
  -khtml-box-shadow: 3px 3px 5px #DFDFDF;
  -o-box-shadow: 3px 3px 5px #DFDFDF;
  box-shadow: 3px 3px 5px #DFDFDF;

}

</style>
CSS-STYLE-SCRIPT-DEFAULT

	elif [[ $DEF_CSS_STYLE == "typewriter" ]]
	then
		cat >> $HTML << CSS-STYLE-SCRIPT-TYPEWRITER
<style type="text/css">

/*------------------------------------------------------------------------
 * Body - Overall page defaults
 *------------------------------------------------------------------------*/

body {
	/* default font */
	font-family: "Courier New", Courier, monospace;

	/* default text color */
	color: black;

	/* default page color */
	background-color: #fff;

	/* provides slight margin space on left and right of whole page */
	margin-left: 25px;
	margin-right: 25px;

	/* font size, adjust to smaller at 93% for alternate look */
	font-size: 85%;
}

/*------------------------------------------------------------------------
 * Paragraphs
 *------------------------------------------------------------------------*/

p {
  line-height: 1.0em;
  font-size: 1.0em;
  margin: 2px 0 2px 0px;
}

.toc_master_paragraph {
  margin-left: 20px;
}

/*------------------------------------------------------------------------
 * Headings
 *------------------------------------------------------------------------*/

/*
	This is an example of how heading styles are used and how they
	are called using bash functions within birdseye

	function      h?  Example             Description
	n/a           h1 "Birdseye Report"    Report Title
	toc_section{} h2 "Hardware Summary"   Titles a section of TOC items
	section{}     h2 "Hardware Summary"   Titles a section of information
	title{}       h3 "Product Name"       Titles a group of related items
	item_title{}    h4 "Product Model"    Title for an item of data

*/

h1, h2, h3, h4, h5, h6 {
	margin: 0 0 3px 0;
}

/* Hovering over the link to the Birdseye Landing page */
h1 a:hover {
	color: black;
  text-decoration: none;
	font-weight: bold;
}

/* Hovering over a heading that links to something */
h2 a:hover,
h3 a:hover,
h4 a:hover {
	color: black;
  text-decoration: none;
}


/*------------------------------------------------------------------------
 * Heading: h1
 *------------------------------------------------------------------------*/

h1 {
  font-size: 1.0em;
  font-weight: bold;
	color: black;
	text-transform: uppercase;
}

/*------------------------------------------------------------------------
 * Heading: h2: Calls attention to sections of data
 *------------------------------------------------------------------------*/

h2 {
  font-size: 1.0em;
  font-weight: bold;
	color: black;
  text-decoration: underline;
	text-transform: uppercase;
}

/*------------------------------------------------------------------------
 * Heading: h3: 
 *------------------------------------------------------------------------*/

/* Used as a title for each item of information being reported */
h3 {
  font-size: 1.0em;
  font-weight: bold;
	color: black;
	text-transform: uppercase;
}

/* Used to show raw commands in title without the title's bold */
.h3_nobold {
	font-weight: normal;
}

/*------------------------------------------------------------------------
 * Heading: h4: 
 *------------------------------------------------------------------------*/

/* Used as a title for each sub-item of information being reported */
h4 {
  font-size: 1.0em;
}

/* Used to show raw commands in title without the title's bold */
.h4_nobold {
	font-weight: normal;
}

/*------------------------------------------------------------------------
 * Heading: h5: 
 *------------------------------------------------------------------------*/

/* Used as a title for each sub-item of information being reported */
h5 {
  font-size: 1.0em;
  font-weight: bold;
  margin: 0px 25px 5px 25px;
}

/* Used to show raw commands in title without the title's bold */
.h5_nobold {
	font-weight: normal;
}

/*------------------------------------------------------------------------
 * Lists
 *------------------------------------------------------------------------*/

/* Used to show raw commands in list items using fixed width fonts */
.list_nobold {
	font-weight: normal;
  font-size: 1.0em;
	font-family: "Courier New", Courier, monospace;
}

/*------------------------------------------------------------------------
 * Links
 *------------------------------------------------------------------------*/

/*
a:link      { color:#3c6eb4; text-decoration: none; }
*/
a:link      { color:black; text-decoration: none; }
a:visited   { color:black; text-decoration: underline; }
a:active    { color:black; text-decoration: underline; }
a:hover     { color:black; text-decoration: underline; background-color: yellow;}

/* Lists */
ol, ul, li {
  margin: 2px 0 2px 0px;
  font-size: 1.0em;
}

li:hover {
	background-color: yellow;
}


/*------------------------------------------------------------------------
 * Pointer to top of page - Replace with cleaner Javascript in future?
 *------------------------------------------------------------------------*/

/* This makes a little box with the word "Top" in it that takes the user
   back to the top of the page */
.boxtop {
	color: #A7ABBE;
  margin: 0px 0px 0px 10px;
}

/* Hovering over the link to the Birdseye Landing page */
.boxtop a:hover {
  color: #EC5800;
	background-color: yellow;
  text-decoration: none;
}

/*------------------------------------------------------------------------
 * Raw Output
 *------------------------------------------------------------------------*/

/*
	Raw output data from commands,
	Presented as a box with soft, rounded corners, 3D shadowing, 
	A different background color,
	Uses a fixed width font to preserve raw output column formatting.
*/

.programlisting {
	font-family: "Courier New", Courier, monospace;
  font-size: 1.0em;
  margin: 0px 25px 20px 25px;
  overflow: auto;

/*
	background-color: rgb(242,242,242);
  border-width: 1px;
  border-style: solid;
  border-radius: 8px;
  padding: 12px;

  border-color: #CFCFCF;
  background-color: rgb(238,232,213);
  box-shadow: 3px 3px 5px #DFDFDF;
  -moz-box-shadow: 3px 3px 5px #DFDFDF;
  -webkit-box-shadow: 3px 3px 5px #DFDFDF;
  -khtml-box-shadow: 3px 3px 5px #DFDFDF;
  -o-box-shadow: 3px 3px 5px #DFDFDF;
  -moz-border-radius: 8px;
  -webkit-border-radius: 8px;
  -khtml-border-radius: 8px;
*/
}

.raw_textarea {
	font-family: "Courier New", Courier, monospace;
  font-size: 1.0em;
  margin: 0px 25px 20px 25px;
  overflow: auto;
}

/*------------------------------------------------------------------------
 * Tips
 *------------------------------------------------------------------------*/
blockquote.tip {
	font-family: "Courier New", Courier, monospace;
  font-size: 1.0em;
  margin: 0px 25px 20px 25px;
  overflow: auto;
	width: 55%;
}

</style>
CSS-STYLE-SCRIPT-TYPEWRITER

	fi # endif - css internal style processing default/typewriter/etc

fi # if/then/else handling ends for CSS external file & inline style

line "</head>"

#--------------------------------------------------------------------------
#
# Report Header
#
#--------------------------------------------------------------------------

line "<body>"

line "<h1><a name=\"Top\"><a href=https://github.com/maxwax/birdseye>Birdseye</a> System Inventory for $MY_HOST</a></h1>" 

paragraph "Produced on $(date "+%A, %B %d %Y at %H:%m") by $MY_NAME ($MY_EMAIL) of $MY_GROUP"

if [[ $MY_FOCUS != "null" ]]
then
	paragraph "Focus of this report <strong>$MY_FOCUS</strong>" 
else
	paragraph "Focus of this report $MY_FOCUS" 
fi

if [[ $MY_HW_NOTES != "null" ]]
then
	paragraph "Notes about this hardware configuration <strong>$MY_HW_NOTES</strong>" 
else
	paragraph "Notes about this hardware configuration $MY_HW_NOTES" 
fi

if [[ $MY_SW_NOTES != "null" ]]
then
	paragraph "Notes about this software configuration <strong>$MY_SW_NOTES</strong>" 
else
	paragraph "Notes about this software configuration $MY_SW_NOTES" 
fi

paragraph "Capture File $OUTPUT_DIR"

# Do we have both a FQDN port for this system and an OOB mgmt port?
if [[ $MY_FQDN != "null" ]] && [[ $MY_OOB != "null" ]]
then

	paragraph "$HOSTNAME is accessibile at $MY_FQDN with an out-of-band mgmt port at <a href=$MY_OOB target=_birdseye_oob>$MY_OOB</a>"

# Do we have only a FQDN port for this system (no OOB mgmt port)?
elif [[ $MY_FQDN != "null" ]]
then
	paragraph "$HOSTNAME is accessibile at $MY_FQDN"
fi

line "<hr>"

#--------------------------------------------------------------------------
#
# Master Table of Contents TOC
#
#--------------------------------------------------------------------------

line "<h2><a name=\"toc\">Table of Contents - Master</a></h2>" 

line "<div class=\"toc_master\">"

paragraph "Linux Environment"

# Linux/Software/Configuration
toc_master "#toc_linux_summary" "Linux Summary"
toc_master "#toc_bootmsgs" 			"Boot messages"
toc_master "#toc_messages"			"Console/System Messages"
toc_master "#toc_configmgmt"		"Config Mgmt Facts"
toc_master "#toc_kernelcfg"	 		"Kernel Configuration"
toc_master "#toc_bootcfg" 			"Boot Configuration"
toc_master "#toc_security" 			"Security Configuration"
toc_master "#toc_modules"		 		"Kernel Modules"
toc_master "#toc_processes"		 	"Processes Running"
toc_master "#toc_hw_sensors"		"Hardware Sensors"
toc_master "#toc_network_cfg"		"Network Configuration"
toc_master "#toc_storage_cfg"		"Storage Configuration"
toc_master "#toc_services"			"Services Configuration"
toc_master "#toc_packages"			"Repositories and Software Packages"
toc_master "#toc_udev"					"Udev configuration"
toc_master "#toc_serial"				"Serial device configuration"
toc_master "#toc_xwindows"			"X-Windows"

paragraph "Hardware Resources"

# Hardware/Device/Physical resources
toc_master "#toc_hw_summary"	 	"Hardware Summary"
toc_master "#toc_cpuinfo"				"Processor/CPU information"
toc_master "#toc_dmidecode"			"System Board Information"
toc_master "#toc_inter"					"Interrupts"
toc_master "#toc_pci"						"Expansion Cards (PCI, PCI-X, PCIe, etc)"
toc_master "#toc_usb"						"USB System"
toc_master "#toc_network_dev"		"Network Devices"
toc_master "#toc_storage"				"Storage Devices"
toc_master "#toc_periphs"				"Peripherals"

paragraph "Virtualization"

# Less widely used configuration/resources
toc_master "#toc_virt" "Virtualization"
toc_master "#toc_xen" "Xen Virtualization"
toc_master "#toc_vms" "Virtual Machines"

line "</div>"
line "<hr>"

#--------------------------------------------------------------------------
#
# Detailed Table of Contents
#
#--------------------------------------------------------------------------

line "<h2><a name=\"toc\">Table of Contents - Detail</a></h2>" 

line "<div class=\"toc_detail\">"

toc_section "toc_linux_summary" "Linux Summary" "#section_linux_summary"
unordered_list_open
list "item_hostname"					"System name" "hostname"
list "item_date"							"System date/time" "date"
list "item_uname"							"System identification" "uname -a"
list "item_issue"							"Distribution, Version" "/etc/issue"
list "item_lsb"								"Distribution, Release" "lsb_release"
list "item_osrelease"					"Distribution, Release" "cat /etc/os-release"
list "item_imageid"						"Distribution, Release" "cat /etc/image-id"
list "item_kerneltaint"				"Distribution, Release" "lsb_release"
list "item_kernelvers"				"Kernel Version & GCC Compile Version" "cat /proc/version"
unordered_list_close

toc_section "toc_bootmsgs"		"Boot messages" "#section_dmesg"

unordered_list_open
list "item_dmesg_notime"			"Linux boot messages (without timestamps)" "dmesg"
list "item_dmesg_time"				"Linux boot messages (with timestamps)" "dmesg"
unordered_list_close

toc_section "toc_messages"		"Console/System Messages" "#section_messages"

unordered_list_open
list "item_messages"					"Linux system log" "cat /var/log/messages | cat /var/log/syslog"
unordered_list_close

toc_section "toc_configmgmt"	"Config Mgmt Facts" "#section_configmgmt"

unordered_list_open
list "item_facter"				 		"Puppet facter items" "facter"
unordered_list_close

toc_section "toc_kernelcfg"		"Kernel Configuration" "#section_kernelcfg"

unordered_list_open
list "item_kernelsinstalled"	"Kernels Installed" "rpm -qa | grep kernel-"
list "item_kerneltaint"				"Kernel Taint Value" "cat /proc/sys/kernel/tainted"
list "item_sysctl"						"System Control Parameters" "sysctl"
#list "item_systemmap"					"System Map" "cat /boot/System.map.$(uname -r)"
unordered_list_close

toc_section "toc_bootcfg"			"Boot Configuration" "#section_bootcfg"

unordered_list_open
list "item_cmdline"						"Boot parameters" "cat /proc/cmdline"
list "item_bootdir"						"Boot directory" "ls -lR /boot"
list "item_efidir"						"EFI Boot directory" "ls -lR /boot/efi"
list "item_grubconf"					"Boot Grub Config File" "cat /boot/grub/grub.conf"
list "item_grubmenulst"				"Boot Grub Menu File" "cat /boot/grub/menu.lst"
list "item_grubdevmap"				"Boot Grub Device Map" "cat /boot/grub/device.map"
list "item_grubconfetc"				"/etc Grub Config File" "cat /etc/grub.conf"
list "item_efibootmgr"				"EFI boot configuration" "efibootmgr"
list "item_elilo"							"ELILO Config (EFI only)" "cat /boot/efi/efi/(dist)/elilo.conf"
list "item_elilolist"					"ELILO List Config (EFI only)" "cat /boot/efi/efi/(dist)/elilo.list"
list "item_redhatgrub"				"EFI: Redhat Grub" "cat /boot/efi/redhat/grub.conf"
unordered_list_close

toc_section "toc_security"		"Security Configuration" "#section_security"
unordered_list_open
list "item_selinux"						"SELinux Status" "cat /etc/selinux/config"
unordered_list_close

toc_section "toc_modules"			"Kernel Modules" "#section_modules"

unordered_list_open
list "item_lsmod"							"Kernel Modules" "lsmod"
list "item_modconf"						"Kernel Module Configuration" "cat /etc/modules.conf"
list "item_modblist"					"Kernel Module Blacklist" "cat /etc/modprobe.d/blacklist.conf"
list "item_modinfo"						"Kernel Module Info" "modinfo"
list "item_moddep"						"Module Dependencies" "cat /lib/modules/(kernel)/modules.dep"
unordered_list_close

toc_section "toc_processes"		"Processes Running" "#section_processes"
unordered_list_open
list "item_processes"					"Processes" "ps axf"
unordered_list_close

toc_section "toc_hw_sensors"	"Hardware Sensors" "#section_hw_sensors"
unordered_list_open
list "item_hw_sensors"				"Hardware Sensors Readings" "sensors"
unordered_list_close

toc_section "toc_network_cfg"	"Network Configuration" "#section_network_cfg"

unordered_list_open
list "item_nics_list"					"Network Device List" "nics (script)"
list "item_resolv"						"DNS Resolution" "cat /etc/resolv.conf"
list "item_hosts"							"Local Hosts" "cat /etc/hosts"
list "item_nsswitch"					"Name Service Switch Config" "cat /etc/nsswitch.conf"
list "item_ifcfg"							"Network Configuration (sysconfig)" "cat /etc/sysconfig/network-scripts/*cfg*"
list "item_networks"					"Network Configuration (debian)" "cat /etc/network/interfaces"
list "item_iproute"						"Network routing table via ip route" "ip route"
list "item_netstat"						"Network routing table via netstat" "netstat"
list "item_firewall"					"Firewall rules" "iptables -L"
unordered_list_close

toc_section "toc_services"		"Services Configuration" "#section_services"
unordered_list_open
list "item_chkconfig"					"Chkconfig" "chkconfig"
list "item_systemctl"					"Systemctl" "chkconfig"
unordered_list_close

toc_section "toc_storage_cfg"	"Storage Configuration" "#section_storage_cfg"

unordered_list_open
list "item_fsblk"							"Filesystem Block Devices" "lsblk -fi"
list "item_fstab"							"Filesystem mount table" "fstab"
list "item_mount"							"Mounted filesystems" "mount"
list "item_pvscan"						"LVM2: Physical Volumes" "pvscan"
list "item_pvs"								"LVM2: Physical Volumes" "pvs"
list "item_vgscan"						"LVM2: Volume Groups" "vgscan"
list "item_vgs"								"LVM2: Volume Groups" "vgs"
list "item_lvscan"						"LVM2: Logical Volumes" "lvscan"
list "item_lvs"								"LVM2: Logical Volumes" "lvs"
unordered_list_close

toc_section "toc_packages"		"Repositories and Software Packages" "#section_packages"
unordered_list_open
if [[ $DIST_PACKAGES == "rpm" ]]
then
	list "item_rpm_config"				"Repository Config (yum)" "cat /etc/yum.repos.d/*"
	list "item_rpm_repos"					"Repositories (yum)" "cat /etc/yum.repos.d/*"
	list "item_rpm_pkgs"					"Installed Packages (rpm)" "rpm -qa | sort"

elif [[ $DIST_PACKAGES == "dpkg" ]]
then
	list "item_apt_config"				"Repository Config (apt)" "cat /etc/apt/apt.conf"
	list "item_apt_repos"					"Repositories (apt)" "cat /etc/apt/sources.list"
	list "item_dpkg_pkgs"					"Installed Packages (dpkg)" "dpkg -l"

elif [[ $DIST_PACKAGES == "zypper" ]]
then
	list "item_zypper_config"			"Repository Config (zypper)" "cat /etc/zypp/zypper.config"
	list "item_zypper_repos"			"Repositories (zypper)" "cat /etc/zypp/repos.d/*"
	list "item_zypper_pkgs"				"Installed Packages (zypper)" "zypper search.."
fi
unordered_list_close

toc_section "toc_udev"				"Udev configuration" "#section_udev"

unordered_list_open
list "item_udevconf"					"udev configuration" "cat /etc/udev.conf"
list "item_udevrules"					"udev rules" "cat /etc/udev/rules.d/*"
unordered_list_close

toc_section "toc_serial"			"Serial device configuration" "#section_serial"

unordered_list_open
list "item_serialdmesg"				"Serial devices in dmesg logs" "dmesg | grep tty<serial>"
list "item_serialproc"				"Serial devices /proc" "cat /proc/tty/drivers/*"
list "item_setserial"					"Serial devices" "setserial -g ttyS[0123456789]"
unordered_list_close

toc_section "toc_xwindows"		"X-Windows" "#section_xwindows"

unordered_list_open
list "item_xrandr"						"X RandR: Resize, Rotate and Reflect Extension Ifno" "xrandr"
list "item_dpyinfo"						"X Display Info" "xdpyinfo"
list "item_glxinfo"						"GLX Info" "glxinfo/glxinfo64"
unordered_list_close

toc_section "toc_hw_summary"  "Hardware Summary" "#section_hw_summary"

unordered_list_open
list "item_product"						"Product Name" "dmidecode -s system-product-name"
list "item_processor_line"		"Processor Summary"
list "item_first_proc"				"First processor" "cat /proc/cpuinfo"
list "item_memsum"						"Memory" "/proc/meminfo"
list "item_bios_vendor"				"BIOS Vendor" "dmidecode -s bios-vendor"
list "item_bios_vers"					"BIOS Version" "dmidecode -s bios-version"
list "item_bios_date"					"BIOS Release Date" "dmidecode -s bios-release-date"
list "item_lsinitrd" 					"initrd information" "lsinitrd"
unordered_list_close

toc_section "toc_dmidecode"		"System Board Information" "#section_dmidecode"

unordered_list_open
list "item_dmidecode"					"System Board information" "dmidecode"
unordered_list_close

toc_section "toc_cpuinfo"			"Processor/CPU information" "#section_processor"

unordered_list_open
list "item_proc_family"				"Processor Family" "dmidecode -s processor-family"
list "item_proc_vers"					"Processor Version" "dmidecode -s processor-version"
list "item_proc_count"				"Processor Count" ""
list "item_processor_lscpu"		"Processor Details" "lscpu"
list "item_processor_lscpue"	"Processor List" "lscpu -e"
list "item_processor_over"		"First Processor" "cat /proc/cpuinfo"
list "item_meminfo"						"Memory Info" "cat /proc/meminfo"
list "item_freemem"						"Free Memory" "free"
list "item_mtrr"							"MTRR" "cat /proc/mtrr"
list "item_numashow"					"NUMA Topology" "numactl --show"
list "item_numahw"						"NUMA Hardware topology" "numactl --hardware"
unordered_list_close

toc_section "toc_inter"				"Interrupts" "#section_inter"

unordered_list_open
list "item_inter"							"Interrupts" "cat /proc/interrupts"
unordered_list_close

toc_section "toc_pci"					"Expansion Cards" "PCI, PCI-X, PCIe, etc" "#section_pci"

unordered_list_open
#list "item_cards"							"Expansion cards" "sutl cards"
list "item_iomem"							"Peripheral IO memory" "cat /proc/iomem"
list "item_ioports"						"Peripheral IO ports" "cat /proc/ioports"
list "item_devices" 					"Devices" "cat /proc/devices"
list "item_lspci"							"PCI devices" "lspci"
list "item_lspcivv"						"PCI Devices Detail" "lspci -vv"
unordered_list_close

toc_section "toc_usb"					"USB subsystem" "#section_usb"

unordered_list_open
list "item_lsusb"							"USB Devices" "lsusb"
list "item_lsusbpy"						"USB Devices Speed & Power" "lsusb.py"
list "item_lsusbv"						"USB Devices Detail" "lsusb -v"
list "item_lsusbt"						"USB Devices Tree" "lsusb -t"
unordered_list_close

toc_section "toc_network_dev"	"Network Devices" "#section_network_devices"

unordered_list_open
list "item_nicinfo"						"Network device summary" "nics (script)"
list "item_lshw_network"			"Network device hardware details" "lshw -c network"
list "item_nicports"					"Network device detail information" "ifconfig, ethtool, ethtool -i"
unordered_list_close

toc_section "toc_storage"  		"Storage" "#section_storage"

unordered_list_open
#list "item_sutlhbas"					"Host Bus Adapter information" "sutl hbas"
list "item_lsblk"							"Block Storage Devices" "lsblk"
list "item_lsscsi"						"SCSI Information" "lsscsi"
list "item_procscsi"					"SCSI Information via proc" "cat /proc/scsi/scsi"

#list "item_qla2xxx"						"Fibre Channel Storage: QLogic (qla2xxx)" "cat /proc/scsi/qla2xxx"
#list "item_lpfc"							"Fibre Channel Storage: Emulex Lightpath (qla2xxx)" "cat /proc/scsi/lpfc"
#list "item_qla2xxx"						"Fibre Channel Storage: Brocade (bfa)" "cat /proc/scsi/bfa"

unordered_list_close

toc_section "toc_periphs"			"Peripherals" "#section_periphs"

unordered_list_open
list "item_cdinfo"						"DVD/CD drive info" "cd-info"
unordered_list_close

toc_section "toc_virt"				"Virtualization" "#section_virt"

unordered_list_open
list "item_kvminfo"						"KVM Version" "modinfo kvm"
list "item_kvmhwinfo"					"KVM Hardware Version" "modinfo kvm_intel | modinfo kvm_amd"
list "item_virshvers"					"Virtualization version" "virsh version"
list "item_virshnodeinfo"			"Virtualization nodes" "virsh nodeinfo"
list "item_virshnodecpu"			"Virtualization nodes cpus" "virsh nodecpustats"
list "item_virshnodemem"			"Virtualization nodes memory" "virsh nodememstats"
list "item_virshnodedevlist"	"Virtualization node devices" "virsh nodedev-list"
list "item_virshnodedevxml"		"Virtualization node devices xml" "virsh nodedev-dumpxml"
list "item_virsh_iflist"			"Virtualization interface List" "virsh iface-list"
list "item_virsh_netlist"			"Virtualization Network List" "virsh net-list"
unordered_list_close

toc_section "toc_vms"					"Virtual Machines" "#section_vms"
unordered_list_open
list "item_vmlist"						"Virtual Machines Defined" "virsh list --all"
list "item_virsh_pool_list"		"Virtualization Storage Pool List" "virsh pool-list"
list "item_virsh_pool_info"		"Virtualization Storage Pool Info" "virsh pool-info"
list "item_virsh_vol_list"		"Virtualization Storage Volume List" "virsh vol-list"
list "item_virsh_vol_info"		"Virtualization Storage Volume Info" "virsh vol-info"
list "item_vm_details"				"Virtual Machine Details" "--"
unordered_list_close

toc_section "toc_xen"					"Xen Virtualization" "#section_xen"

unordered_list_open
list "item_xenconfig"					"Xen Configuration" "cat /etc/xen/xend-config.sxp"
unordered_list_close

line "</div>"

line "<hr>"

echo "Table of Contents constructed"

#--------------------------------------------------------------------------
#
# Linux Summary - The Basics: System Name, Date/time, Distribution
#
#--------------------------------------------------------------------------

section "section_linux_summary" "Linux Summary"

item_title "item_hostname"	"System name" "hostname"
raw_open
hostname >> $HTML 2>&1
raw_close

item_title "item_date"		"System date/time" "date"
raw_open
date >> $HTML 2>&1
raw_close

item_title "item_hwclock"		"Hardware Clock System date/time" "hwclock"
raw_open
if [[ $VM_GUEST == "no" ]]
then
	hwclock >> $HTML 2>&1
else
	line "There is no hardware clock in a $VM_GUEST virtual machine."
fi
raw_close

item_title "item_uname"		"System identification" "uname -a"
raw_open
uname -a >> $HTML 2>&1
raw_close

item_title "item_issue"		"Distribution, Version" "/etc/issue"
raw_open
cat /etc/issue >> $HTML 2>&1
raw_close

item_title "item_lsb"			"Distribution, Release" "lsb_release"
raw_open
if [[ $AVAILABLE_LSB_RELEASE == "yes" ]]
then
	lsb_release -d >> $HTML 2>&1
else
	line "The 'lsb_release' command is not available on this system."
fi
raw_close

item_title "item_osrelease"	"Distribution, Release" "cat /etc/os-release"
raw_open
if [[ -f /etc/os-release ]]
then
	cat /etc/os-release  >> $HTML 2>&1
else
	line "The /etc/os-release file is not available on this system."
fi
raw_close

item_title "item_imageid"	"Distribution, Image ID" "cat /etc/image-id"
raw_open
if [[ -f /etc/image-id ]]
then
	cat /etc/image-id >> $HTML 2>&1
else
	line "The /etc/image-id file is not available on this system."
fi
raw_close

item_title "item_kernelvers"			"Kernel Version & GCC Compile Version" "cat /proc/version"
raw_open
cat /proc/version >> $HTML 2>&1
raw_close

#--------------------------------------------------------------------------
#
# Log Files
#
#--------------------------------------------------------------------------

section "section_dmesg" "Boot messages"

item_title "item_dmesg_notime"		"Linux boot messages without timestamps" "dmesg --notime"

if [[ $FEATURE_DMESG_NOTIME == "yes" ]]
then
	textarea_open 120 24
	dmesg --notime >> $HTML 2>&1
	textarea_close

	dmesg --notime >> $FILE_DMESG_NOTIME
else
	# Show dmesg output using default output information for this dist.
	raw_open
	line "'dmesg --notime' is not available on this system."
	raw_close

	dmesg >> $FILE_DMESG_NOTIME

	# If we can determine who shows timestamps by default, then 
	# we can cut them out manually here
	#	dmesg | cut -c15-254 >> $HTML 2>&1
	#	dmesg | cut -c15-254 >> $FILE_DMESG_NOTIME
fi

item_title "item_dmesg_time"		"Linux boot messages with timestamps" "dmesg"
textarea_open 120 24
if [[ $FEATURE_DMESG_CTIME == "yes" ]]
then
	dmesg --ctime >> $HTML 2>&1
	dmesg --ctime >> $FILE_DMESG
else
	dmesg >> $HTML 2>&1
	dmesg >> $FILE_DMESG
fi
textarea_close

helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_DMESG target=_file_dmesg>separate dmesg info file.</a>"

section "section_configmgmt" "Config Mgmt Facts"

item_title "item_facter"	"Puppet Facter" "facter"

if [[ $AVAILABLE_LSB_RELEASE == "yes" ]]
then
	textarea_open 120 24
	facter >> $HTML 2>&1
	textarea_close
else
	line "The Puppet 'facter' command is not available on this system."
fi

section "section_messages" "Console/System Messages"

item_title "item_messages"	"Linux system log" "cat /var/log/messages | cat /var/log/syslog"

# need to edit for debian, newer fedora, etc
if [ -f /var/log/messages ]
then
	declare -i MSG_LINES

	# Check the size of /var/log/messages
	MSG_LINES=$(wc -l /var/log/messages | awk -F " " '{print $1}')

	raw_caption "cap_messages" "cat /var/log/messages"
	textarea_open 120 24

	# A large messages file is usually full of unwanted crap like
	# sound card and GUI errors.  So lets show only a reasonable amount
	# if the file is very large.
	if [[ $MSG_LINES -gt 25000 ]]
	then
		# file is longer than 25000 lines
		echo "/var/log/messages is $MSG_LINES long.  This is the last 25000 lines" >> $HTML 2>&1
		tail -n 25000 /var/log/messages >> $HTML 2>&1
	else
		# file is shorter than 25000 lines
		cat /var/log/messages >> $HTML 2>&1
	fi

	textarea_close

	echo "/var/log/messages:" >> $FILE_MSGS
	cat /var/log/messages >> $FILE_MSGS

	helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_MSGS target=_file_msgs>separate messages file.</a>"
fi

if [ -f /var/log/syslog ]
then

	raw_caption "cap_syslog" "cat /var/log/syslog"
	textarea_open 120 24
	cat /var/log/syslog >> $HTML 2>&1
	textarea_close

	echo "/var/log/syslog:" >> $FILE_SYSLOG
	cat /var/log/syslog >> $FILE_SYSLOG

	helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_SYSLOG target=_file_msgs>separate syslog file.</a>"
fi

#--------------------------------------------------------------------------
#
# Kernel Configuration
#
#--------------------------------------------------------------------------

section "section_kernelcfg" "Kernel Configuration"

item_title "item_kernelsinstalled" "Installed Kernels" "rpm -qa | grep -kernel"
if [[ $DIST_PACKAGES == "rpm" ]]
then
	raw_open
	rpm -qa | fgrep "kernel-" | grep -v "devel" | grep -v "header" >> $HTML 2>&1
	raw_close
elif [[ $DIST_PACKAGES == "dpkg" ]]
then
	raw_open
	# Check to see if any 'linux-image' kernel packages exist
	if [[ $(dpkg -l | grep linux-image | wc -l) -eq 0 ]]
	then
		# didn't find any, is this Google Compute Engine?
		if [[ $(dpkg -l | grep -i "Compute Engine" | wc -l) -gt 0 ]]
		then
			line "No 'linux-image' kernel packages were found."
			line "These files suggest this is Google Compute Engine"
			dpkg -l | grep -i "Compute Engine" >> $HTML 2>&1
		fi
	else
		dpkg -l | grep linux-image >> $HTML 2>&1
	fi
	raw_close
elif [[ $DIST_PACKAGES == "zypper" ]]
then
	raw_open
	line "Birdseye needs to be configured to find zypper kernel packages."
	raw_close
else
	raw_open
	line "Birdseye needs additional functionality to determine ${DIST_NAME}'s installed kernels, Sorry."
	raw_close
fi

item_title "item_kerneltaint"		"Kernel Tainted Value" "cat /proc/sys/kernel/tainted"
raw_open
cat /proc/sys/kernel/tainted >> $HTML 2>&1
raw_close

item_title "item_sysrq"	"Magic SysRq Key Enablement" "cat /proc/sys/kernel/sysrq"

SYSRQ_ENABLE=$(cat /proc/sys/kernel/sysrq)
raw_open
if [[ $SYSRQ_ENABLE == "0" ]]
then
	line "The Magic SysRq feature is not enabled."
elif [[ $SYSRQ_ENABLE == "0" ]]
then
	line "The Magic SysRq feature is enabled."
else
	line "/proc/sys/kernel/sysrq reports $SYSRQ_ENABLE"
fi
raw_close

item_title "item_sysctl"	"System Control Parameters" "sysctl"

textarea_open 120 24
sysctl -a >> $HTML 2>&1
textarea_close

#item_title "item_systemmap"	"System Map" "cat /boot/System.map.$(uname -r)"

#if [[ -f /boot/System.map-$(uname -r) ]]
#then
#	textarea_open 120 24
#	cat /boot/System.map-$(uname -r)  >> $HTML 2>&1
#	textarea_close
#else
#	raw_open
#	line "I cannot find a System.map file for kernel " $(uname -r) " in /boot."
#	raw_close
#fi

#--------------------------------------------------------------------------
#
# Boot Configuration
#
#--------------------------------------------------------------------------

section "section_bootcfg" "Boot Configuration"

item_title "item_cmdline"		"Boot parameters" "cat /proc/cmdline"
raw_open
cat /proc/cmdline >> $HTML 2>&1
raw_close

item_title "item_bootdir"		"Boot directory" "ls -l /boot"
# Check for this directory; Not sure why we wouldn't have it but..
if [[ -d /boot ]]
then
	# count the number of output lines 
	BOOT_LINES=$(ls -lR /boot | wc -l)

	# If we have more > 0 and <= 15 then show it in short format
	text_open $BOOT_LINES 120 24
	ls -lR /boot >> $HTML 2>&1
	text_close
else
	raw_open
	line "I can't find a /boot directory on this system!"
	raw_close
fi

item_title "item_efidir"		"EFI Boot directory" "ls -l /boot/efi"
# Check to see if we have a /boot/efi directory - this may be a BIOS system
if [[ -d /boot/efi ]]
then
	# count the number of output lines 
	EFI_BOOT_LINES=$(ls -lR /boot/efi | wc -l)

	text_open $EFI_BOOT_LINES 120 24
	ls -lR /boot/efi >> $HTML 2>&1
	text_close
else
	raw_open
	line "There is no /boot/efi directory on this system."
	raw_close
fi

EFI_BOOT="null"

# defaults to /boot/grub2
MY_BOOT_DIR="$DIST_BOOT_CFG"

# We should only have /sys/firwmare/efi on an EFI system
if [[ -d /sys/firmware/efi ]]
then
	EFI_BOOT="yes"

	#	Find out what kernel we booted: remove 'BOOT_IMAGE=dev0000:\"
	MY_CMDLINE=$(cat /proc/cmdline)

	if [[ $DEBUG == "yes" ]]
	then
		echo "EFI Processing: MY_CMDLINE $MY_CMDLINE"
		echo
	fi

	# EFI systems in native EFI boot manager mode provides us
	# with a sophisticated path to efi boot images via /proc/cmdline
	if [[ $MY_CMDLINE = *:\\efi* ]]
	then

		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: We see a native EFI /proc/cmdline"
			echo
		fi

		# Real system example
		# BOOT_IMAGE=dev000:\efi\SuSE\vmlinuz-3.0.76-0.11-default root=/dev/disk/by-id/scsi-3600c0ff000db1c6597969f5101000000-part3  resume=/dev/disk/by-id/scsi-3600c0ff000db1c6597969f5101000000-part2 splash=silent crashkernel=256M-:128M showopts console=ttyS0,115200

		# Remove prefix 'BOOT_IMAGE=dev0000:\"
		MY_CMDLINE=${MY_CMDLINE#*:\\}
		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: Remove Leading Info $MY_CMDLINE"
			echo
		fi

		# Remove suffix "root=..."
		MY_CMDLINE=${MY_CMDLINE%% *}
		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: Remove Trailing Info $MY_CMDLINE"
			echo
		fi

		# Remove suffix "\vmlinuz.."
		MY_CMDLINE=${MY_CMDLINE%\\*}
		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: Remove Kernel Name $MY_CMDLINE"
			echo
		fi

		# Result: /boot/efi/efi/SuSE /boot/efi/efi/Fedora
		MY_BOOT_DIR="/boot/efi/${MY_CMDLINE}"
		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: MY_BOOT_DIR $MY_BOOT_DIR"
		fi

		# Change EFI DOS style backslashes to Linux style forward-slashes
		MY_BOOT_DIR=${MY_BOOT_DIR//\\//}
		if [[ $DEBUG == "yes" ]]
		then
			echo "EFI Processing: Change backslashes to slashes MY_BOOT_DIR $MY_BOOT_DIR"
		fi

	fi

else
	EFI_BOOT="no"
fi

if [[ $DEBUG == "yes" ]]
then
	echo "Boot Configuration: MY_BOOT_DIR FINAL $MY_BOOT_DIR"
	echo "Boot Configuration: DIST_UEFI_DIR $DIST_UEFI_DIR"
fi

item_title "item_grubconf" "GRUB Config File" "cat grub.cfg"
if [[ -f $MY_BOOT_DIR/$DIST_GRUB_CONF ]]
then
	paragraph "Reporting on $MY_BOOT_DIR/$DIST_GRUB_CONF"

	# count the number of output lines
	GRUB_LINES=$(cat $MY_BOOT_DIR/$DIST_GRUB_CONF | wc -l)

	text_open $GRUB_LINES 120 24
	cat $MY_BOOT_DIR/$DIST_GRUB_CONF >> $HTML 2>&1
	text_close
else

	if [[ $EFI_BOOT == "yes" ]] && [[ -f $DIST_UEFI_DIR/$DIST_GRUB_CONF ]]
	then
		paragraph "Reporting on $DIST_UEFI_DIR/$DIST_GRUB_CONF"

		# count the number of output lines
		GRUB_LINES=$(cat $DIST_UEFI_DIR/$DIST_GRUB_CONF | wc -l)

		text_open $GRUB_LINES 120 24
		cat $DIST_UEFI_DIR/$DIST_GRUB_CONF >> $HTML 2>&1
		text_close

	else
		raw_open
		line "$DIST_GRUB_CONF is not available in the expected places."
		raw_close
	fi
fi

item_title "item_grubmenulst"		"GRUB Config File" "cat menu.lst"
if [[ -f $MY_BOOT_DIR/menu.lst ]]
then
	paragraph "Reporting on $MY_BOOT_DIR/menu.lst"

	# count the number of output lines 
	GRUB_LINES=$(cat $MY_BOOT_DIR/menu.lst | wc -l)

	text_open $GRUB_LINES 120 24
	cat $MY_BOOT_DIR/menu.lst >> $HTML 2>&1
	text_close

else

	if [[ $EFI_BOOT == "yes" ]] && [[ -f $DIST_UEFI_DIR/menu.lst ]]
	then
		paragraph "Reporting on $DIST_UEFI_DIR/menu.lst"

		# count the number of output lines
		GRUB_LINES=$(cat $DIST_UEFI_DIR/menu.lst | wc -l)
	
		text_open $GRUB_LINES 120 24
		cat $DIST_UEFI_DIR/menu.lst >> $HTML 2>&1
		text_close

	else
		raw_open
		line "'menu.lst' is not avaialble in the expected places."
		raw_close
	fi

fi

item_title "item_grubdevmap"		"GRUB Device Map" "cat device.map"
raw_open
if [[ -f $MY_BOOT_DIR/device.map ]]
then
	paragraph "Reporting on $MY_BOOT_DIR/device.map"
	cat $MY_BOOT_DIR/device.map >> $HTML 2>&1
else
	line "$MY_BOOT_DIR/device.map is not available."
fi
raw_close

item_title "item_efibootmgr"		"EFI Boot Configuration" "efibootmgr"
if [[ $EFI_BOOT == "yes" ]]
then

	if [[ $AVAILABLE_EFI_BOOTMGR == "yes" ]]
	then
		textarea_open 120 24
		efibootmgr >> $HTML 2>&1
		textarea_close
	else
		raw_open
		line "efibootmgr is not present on this system." 
		raw_close
	fi

else
	raw_open
	line "This is not an EFI system - Skipping EFI Boot Configuration reporting."
	raw_close
fi

item_title "item_elilocfg"		"ELILO Config File" "cat elilo.conf"
if [[ $EFI_BOOT == "yes" ]]
then
	if [[ -f $MY_BOOT_DIR/elilo.conf ]]
	then
		paragraph "Reporting on $MY_BOOT_DIR/elilo.conf"

		textarea_open 120 24
		cat $MY_BOOT_DIR/elilo.conf >> $HTML 2>&1
		textarea_close
	else
		raw_open
		line "$MY_BOOT_DIR/elilo.conf is not present on this system."
		raw_close
	fi

	item_title "item_elilolist"		"ELILO List Config File" "cat elilo.list"
	if [[ -f $MY_BOOT_DIR/elilo.list ]]
	then
		paragraph "Reporting on $MY_BOOT_DIR/elilo.list"

		textarea_open 120 24
		cat $MY_BOOT_DIR/elilo.list >> $HTML 2>&1
		textarea_close
	else
		raw_open
		line "$MY_BOOT_DIR/elilo.conf is not present on this system."
		raw_close
	fi

else
	raw_open
	line "This is not an EFI system - Skipping ELILO reporting." 
	raw_close
fi

#--------------------------------------------------------------------------
#
# Security Configuration
#
#--------------------------------------------------------------------------
section "section_security" "Security Configuration"

item_title "item_selinux"		"SELinux Configuration" "cat /etc/selinux/config"

if [ $PUBLIC_REPORT = "yes" ]
then
	raw_open
	line "This is a public report and no security information is included."
	raw_close
else
	if [[ -f /etc/selinux/config ]]
	then
		raw_open
		cat /etc/selinux/config >> $HTML 2>&1
		raw_close
	else
		raw_open
		line "This system does not have an /etc/selinux/config file."
		raw_close
	fi
fi

#--------------------------------------------------------------------------
#
# Kernel Modules
#
#--------------------------------------------------------------------------

section "section_modules" "Kernel Modules"

item_title "item_lsmod"		"Kernel Modules" "lsmod"
if [[ $AVAILABLE_LSMOD == "yes" && $LSMOD_WORKS == "yes" ]]
then
	textarea_open 120 24
	lsmod >> $HTML 2>&1
	textarea_close
else
	raw_open
	line "lsmod is not available on this system. Is it a virtual machine?"
	raw_close
fi

item_title "item_modconf"		"Kernel Module Configuration" "cat /etc/modules.conf"
raw_open
if [[ -f /etc/modules.conf ]]
then
	cat /etc/modules.conf >> $HTML 2>&1
else
	line "/etc/modules.conf is not available on this system."
fi
raw_close

item_title "item_modblist"		"Kernel Module Blacklist" "cat /etc/modprobe.d/blacklist.conf"
if [[ -f /etc/modprobe.d/blacklist.conf ]]
then
	BLACKLIST_LINES=$(cat /etc/modprobe.d/blacklist.conf | wc -l)

	text_open $BLACKLIST_LINES 120 24
	cat /etc/modprobe.d/blacklist.conf >> $HTML 2>&1
	text_close
else
	raw_open
	line "/etc/blacklist.conf is not available on this system."
	raw_close
fi

item_title "item_modinfo"	"Kernel Module Info" "modinfo"
if [[ $AVAILABLE_LSMOD == "yes" && $LSMOD_WORKS == "yes" ]]
then
	textarea_open 120 24
	for EACHMOD in $(lsmod | grep -v Module | awk -F " " '{print $1}')
	do
		line ""
		modinfo $EACHMOD >> $HTML 2>&1
	done
	textarea_close

else
	raw_open
	line "lsmod is not available on this system. Is it a virtual machine?"
	raw_close
fi

item_title "item_moddep"	"Module Dependencies" "cat /lib/modules/(kernel)/modules.dep"
if [[ $(cat /lib/modules/$(uname -r)/modules.dep 2>&1 | grep "No such file" | wc -l) -eq 0 ]]
then
	textarea_open 120 24
	cat /lib/modules/$(uname -r)/modules.dep >> $HTML 2>&1
	textarea_close
else
	raw_open
	line "/lib/modules/$(uname -r)/modules.dep is not available on this system. Is it a virtual machine?"
	raw_close
fi

#--------------------------------------------------------------------------
#
# Network Configuration
#
#--------------------------------------------------------------------------

section "section_processes" "Processes Running"

item_title "item_processes"	"Processes" "ps axf"
line "The processes shown here were running at the time of this Birdseye report and may not reflect the processes running at an earlier time of importance."
textarea_open 120 24
ps axf >> $HTML 2>&1
textarea_close

#--------------------------------------------------------------------------
#
# Hardware Sensors
#
#--------------------------------------------------------------------------

section "section_hw_sensors" "Hardware Sensors"

item_title "item_hw_sensors"	"Hardware Sensor Readings" "sensors"
line "The sensor readings shown here are accurate as of the time of this Birdseye report and may not reflect the readings at an earlier time of importance."
if [[ $AVAILABLE_SENSORS == "yes" ]]
then
	# count the number of output lines
	SENSORS_LINES=$(sensors | wc -l)

	text_open $SENSORS_LINES 120 24
	sensors $USE_FARENHEIT >> $HTML 2>&1
	text_close
else
	raw_open
	line "The lm_sensors package's 'sensors' program is not available on this system."
	raw_close
fi

#--------------------------------------------------------------------------
#
# Network Configuration
#
#--------------------------------------------------------------------------

section "section_network_cfg" "Network Configuration"

item_title "item_nics_list"		"Network Device List" "nics"
if [ $PUBLIC_REPORT = "yes" ]
then
	raw_open
	line "This is a public report and no IP network information is included."
	raw_close
else
	raw_open
	nic_list >> $HTML 2>&1
	raw_close
fi

item_title "item_resolv"		"DNS Resolution" "cat /etc/resolv.conf"
raw_open
cat /etc/resolv.conf >> $HTML 2>&1
raw_close

item_title "item_hosts"		"Local Hosts" "cat /etc/hosts"
# Count the number of lines in output
HOST_LINES=$(cat /etc/hosts | wc -l)

text_open $HOST_LINES 120 24
cat /etc/hosts >> $HTML 2>&1
text_close

item_title "item_nsswitch" "Name Service Switch Config" "cat /etc/nsswitch"
if [[ -f /etc/nsswitch.conf ]]
then
	# Count the number of lines in output
	NSSWITCH_LINES=$(cat /etc/nsswitch.conf | wc -l)

	text_open $NSSWITCH_LINES 120 24
	cat /etc/nsswitch.conf >> $HTML 2>&1
	text_close
else
	raw_open
	line "/etc/nsswitch.conf is not available on this system."
	raw_close
fi


item_title "item_ifcfg" "Network Configuration (sysconfig)" "cat /etc/sysconfig/network-scripts/*cfg*"

if [[ $DIST_SYSCONFIG == "yes" ]]
then
	if [[ -f /etc/sysconfig/network ]]
	then
		raw_caption "cap_sysconfig_network" "cat /etc/sysconfig/network"
		raw_open
		cat /etc/sysconfig/network >> $HTML 2>&1
		raw_close
	else
		raw_open
		line "There is no /etc/sysconfig/network file available on this system."
		raw_close
	fi

	# Do we have a sysconfig network script directory?
	# like /etc/sysconfig/network-scripts on Red Hat?
	if [[ -d $DIST_SYSCONFIG_NETDIR ]]
	then

		# If we are a Suse system and we have a file called 'config'
		# in the netconfig dir, it has all sorts of interesting information
		# so let's report on it
		if [[ $DIST_FAMILY == "Suse" && -f $DIST_SYSCONFIG_NETDIR/config ]]
		then
			raw_caption "cap_suse_netdir_config" "Suse: cat $DIST_SYSCONFIG_NETDIR/config"
			textarea_open 120 24
			cat $DIST_SYSCONFIG_NETDIR/config >> $HTML 2>&1
			textarea_close
		fi

		if [[ $(ls -l ${DIST_SYSCONFIG_NETDIR}/*cfg-* | wc -l) -gt 0 ]]
		then
			# Look for ifcfg-eth0, ifcfg-p99p9, br0-cfg, brcfg0 etc
			for EACH_FILE in ${DIST_SYSCONFIG_NETDIR}/*cfg-*
			do
				raw_caption "cap_net_cfgs" "cat $EACH_FILE"
				raw_open
				cat $EACH_FILE >> $HTML 2>&1
				raw_close
			done
		else
			raw_open
			line "There are no $DIST_SYSCONFIG_NETDIR/*cfg-* files available on this system."
			raw_close
		fi
	else
		raw_open
		line "There is no $DIST_SYSCONFIG_NETDIR directory available on this system."
		raw_close
	fi

else
	raw_open
	line "This information is not available on a non-sysconfig distribution."
	raw_close	
fi #endif - report on a sysconfig system.

item_title "item_networks" "Network Configuration (debian)" "cat /etc/network/interfaces"
if [[ $DIST_SYSCONFIG == "no" ]]
then
	if [[ -f /etc/network/interfaces ]]
	then
		INTERFACES_LINES=$(cat /etc/network/interfaces | wc -l)
		text_open $INTERFACES_LINES 120 24
		cat /etc/network/interfaces >> $HTML 2>&1
		text_close
	else
		raw_open
		line "There is no /etc/network/interfaces file available on this system."
		raw_close
	fi
else
	raw_open
	line "This information is not available on a sysconfig distribution."
	raw_close	
fi # endif - report on a debian (non sysconfig) system

item_title "item_iproute"		"Network routing table via ip route" "ip route"
raw_open
if [ $PUBLIC_REPORT = "yes" ]
then
	line "This is a public report and no routing information is included."
else
	ip route  >> $HTML 2>&1
fi
raw_close

item_title "item_netstat"		"Network routing table via netstat" "netstat"
raw_open
if [ $PUBLIC_REPORT = "yes" ]
then
	line "This is a public report and no routing information is included."
else
	netstat -nr >> $HTML 2>&1
fi
raw_close

item_title "item_firewall"		"Firewall rules" "iptables -L"

if [ $PUBLIC_REPORT = "yes" ]
then
	line "This is a public report and no firewall information is included."
else
	IPTABLES_LINES=$(iptables -L | wc -l)
	text_open $IPTABLES_LINES 120 24
	iptables -L >> $HTML 2>&1
	text_close
fi

#--------------------------------------------------------------------------
#
# Storage Configuration
#
#--------------------------------------------------------------------------

section "section_storage_cfg" "Storage Configuration"

item_title "item_fsblk"		"File System Block Devices" "lsblk -i"
if [[ $AVAILABLE_LSBLK == "yes" ]]
then
	FSBLOCK_LINES=$(lsblk -i | wc -l)
	text_open $FSBLOCK_LINES 160 24
	# -i option uses ASCII characters for tree relationships +--^ etc
	# -f show filesystem information
	lsblk -i >> $HTML 2>&1
	text_close	
fi

item_title "item_fstab" "Filesystem mount table" "fstab"
raw_open
cat /etc/fstab >> $HTML 2>&1
raw_close

item_title "item_mount"		"Mounted filesystems" "mount"
MOUNT_LINES=$(mount | wc -l)
text_open $MOUNT_LINES 140 24
mount >> $HTML 2>&1
text_close

# Enable by default" (most RHEL and Fedora use LVM)
SHOW_LVM="yes"

if [[ $AVAILABLE_PVSCAN == "yes" ]]
then

	PV_RESULTS=$(pvscan 2>&1 | grep "  No matching physical volumes found" | wc -l)

	if [ $PV_RESULTS -ge 1 ]
	then
		SHOW_LVM="no"
	fi
else
	SHOW_LVM="no"
fi

item_title "item_pvscan" "LVM2: Physical Volumes" "pvscan"
# Regardless of whether physical volumes were found above, let pvscan
# report the status to the user.  Then use the SHOW_LVM variable set above
# to determine whether volume groups and logical volumes are processed.
# Skip those commands if no physical volumes are present)
if [[ $AVAILABLE_PVSCAN == "yes" ]]
then
	raw_open
	pvscan >> $HTML 2>&1
	raw_close
else
	raw_open
	line "pvscan is not available on this system."
	raw_close
fi

item_title "item_pvs" "LVM2: Volume Groups" "pvs"
raw_open

if [ $SHOW_LVM == "yes" ]
then
	pvs >> $HTML 2>&1 
else
	line "pvs is not available on this system."
fi
raw_close

item_title "item_vgscan" "LVM2: Volume Groups" "vgscan"
raw_open
if [ $SHOW_LVM == "yes" ]
then
	vgscan >> $HTML 2>&1
else
	line "vgscan is not available on this system."
fi
raw_close

item_title "item_vgs" "LVM2: Volume Groups" "vgs"
raw_open
if [ $SHOW_LVM == "yes" ]
then
	vgs >> $HTML 2>&1
else
	line "vgs is not available on this system."
fi
raw_close

item_title "item_lvscan" "LVM2: Logical Volumes" "lvscan"
raw_open
if [ $SHOW_LVM == "yes" ]
then
	lvscan >> $HTML 2>&1
else
	line "lvscan is not availble on this system."
fi
raw_close

item_title "item_lvs" "LVM2: Logical Volumes" "lvs"
raw_open
if [ $SHOW_LVM == "yes" ]
then
	lvs >> $HTML 2>&1
else
	line "lvs is not available on this system."
fi
raw_close

#--------------------------------------------------------------------------
#
# Services Configuration
#
#--------------------------------------------------------------------------

section "section_services" "Services Configuration"
item_title "item_chkconfig"	"Chkconfig" "chkconfig"
if [[ $AVAILABLE_CHKCONFIG == "yes" ]]
then
	textarea_open 120 24
	chkconfig --list >> $HTML 2>&1
	textarea_close	
else
	raw_open
	line "chkconfig is not present on this system."
	raw_close
fi

item_title "item_systemctl"		"Systemctl" "systemctl"
if [[ $AVAILABLE_SYSTEMCTL == "yes" ]]
then
	textarea_open 120 24
	systemctl >> $HTML 2>&1
	textarea_close	
else
	raw_open
	line "systemctl is not present on this system."
	raw_close
fi

#--------------------------------------------------------------------------
#
# Repositories and Installed Packages
#
#--------------------------------------------------------------------------

section "section_packages" "Repositories and Software Packages"

if [[ $DIST_PACKAGES = "rpm" ]]
then

	#--------------------------------------------------------------------------
	# RPM/YUM Repositories

	item_title "item_rpm_config"		"Software Repositories (rpm/yum)" "cat /etc/yum.conf"

	# Report contents of yum.conf - the yum master configuration file
	textarea_open 120 24
	if [[ -f /etc/yum.conf ]]
	then
		cat /etc/yum.conf >> $HTML 2>&1
	fi
	textarea_close

	# Report contents of individual repositories configured for use with yum
	item_title "item_rpm_repos"		"Yum Repositories" "cat /etc/yum.repos.d/*.repo"
	textarea_open 120 24
	for EACHFILE in /etc/yum.repos.d/*.repo
	do
		line ""
		line "Repository config file: $EACHFILE"
		line "----------"
		cat "$EACHFILE" >> $HTML 2>&1
	done
	textarea_close

	item_title "item_rpm_pkgs"		"Installed RPM Packages" "rpm -qa | sort"

	textarea_open 120 24
	rpm -qa | sort >> $HTML 2>&1
	textarea_close

elif [[ $DIST_PACKAGES = "dpkg" ]]
then

	#--------------------------------------------------------------------------
	# DPKG/APT Repository

	item_title "item_apt_config"		"Software Repositories (dpkg/apt)" "cat /etc/apt/apt.conf"

	if [[ -f /etc/apt/apt.conf ]]
	then
		textarea_open 120 24
		cat /etc/apt/apt.conf >> $HTML 2>&1
		textarea_close
	else
		raw_open
		line "There is no /etc/apt/apt.conf available this system."
		raw_close
	fi

	# Debian/Ubuntu/etc: Report sources.l
	item_title "item_apt_repos"		"dpkg Repositories" "cat /etc/apt/sources.list"
	if [[ -f /etc/apt/sources.list ]]
	then

		SOURCES_LINES=$(cat /etc/apt/sources.list | wc -l)
		text_open $SOURCES_LINES 120 24
		EACHFILE="/etc/apt/sources.list"
		line ""
		line "Repository config file: $EACHFILE"
		line "----------"
		cat "$EACHFILE" >> $HTML 2>&1
		text_close
	else
		raw_open
		line "There is no /etc/apt/sources.list available this system."
		raw_close
	fi

	item_title "item_dpkg_pkgs"	"Debian Packages" "dpkg -l"
	textarea_open 120 24
	dpkg -l >> $HTML 2>&1
	textarea_close

elif [[ $DIST_PACKAGES = "zypper" ]]
then

	#--------------------------------------------------------------------------
	# SuSE Zypper Repository

	item_title "item_zypper_config"		"Software Repositories (SuSE)" "cat /etc/zypp/zypper.conf"

	# Check to see if we have this file.
	if [[ -f /etc/zypp/zypper.conf ]]
	then
		# Count the number of output lines
		ZIPP_LINES=$(cat /etc/zypp/zypper.conf | wc -l) 

		# If we have > 0 and < 15 then use the short form
		text_open $ZIPP_LINES 120 24
		cat /etc/zypp/zypper.conf >> $HTML 2>&1
		text_close
	fi

	# Report contents of individual repositories configured for use with zypper
	item_title "item_zypper_repos"		"Software Repositories (SuSE)" "cat /etc/zypp/
repos.d/*"
	textarea_open 120 24
	for EACHFILE in /etc/zypp/repos.d/*.repo
	do
		line ""
		line "Repository config file: $EACHFILE" 
		line "----------" 
		cat "$EACHFILE" >> $HTML 2>&1
	done
	textarea_close

	item_title "item_zypper_pkgs"	"Zypper Packages" "zypper_packages"
	textarea_open 120 24
	zypper search | grep "i |" >> $HTML 2>&1
	textarea_close
fi

#--------------------------------------------------------------------------
#
# udev Configuration
#
#--------------------------------------------------------------------------

section "section_serial" "Serial device configuration"

item_title "item_serialdmesg"	"Serial log in dmesg" "dmesg | grep tty"
# standard serial ports - try to ignore non-serial console tty devices
# This should catch ttyS01 as well as ttyUSB01 and similar
if [[ $(dmesg | grep "tty" | grep -v "tty[0123456789]" | wc -l) -gt 0 ]]
then
	line "Logs related to serial ports have been seen in the past but those ports may not <strong>currently</strong> be available."
	raw_open
	dmesg | grep "tty" | grep -v "tty[0123456789]" >> $HTML 2>&1
	raw_close
else
	raw_open
	line "Information about serial ports is not available in the dmesg logs."
	raw_close
fi

item_title "item_serialproc"	"Serial devices in /proc" "cat /proc/tty/driver/*"
line
for EACH_SERIAL_TYPE in /proc/tty/driver/*
do
	raw_caption "cap_serial_driver" "${EACH_SERIAL_TYPE}:"
	raw_open
	cat $EACH_SERIAL_TYPE >> $HTML 2>&1
	raw_close
done

item_title "item_setserial"	"Serial devices" "setserial -g ttyS#"

# Default this flag to no, we haven't seen/processed any ports
SERIAL_PORTS_SEEN="no"

# Loop on each type of serial port known
for EACH_SERIAL_PREFIX in S USB
do

	# Loop on first ten serial ports. Haven't more than ten in a long time?
	for EACH_SERIAL_NUMBER in {0..9}
	do

		# Let's set this variable to an actual serial port device name
		EACH_SERIAL_DEVICE="/dev/${EACH_SERIAL_PREFIX}${EACH_SERIAL_NUMBER}"

		if [[ $DEBUG == "yes" ]]
		then
			echo "Serial Scanning $EACH_SERIAL_DEVICE"
		fi
		
		if [[ -c $EACH_SERIAL_DEVICE ]]
		then

			# The presence of UART chips on the computer may cause /dev/ttyS#
			# entries to appear even when actual ports do not exist.
			# If stty fails, then we probably don't have a real port.
			# set serial will still run.
			stty < $EACH_SERIAL_DEVICE > /dev/null 2>&1
			if (( $? == 0 ))
			then

				if [[ $DEBUG == "yes" ]]
				then
					echo "Device $EACH_SERIAL_DEVICE is present."
				fi
	
				# If the setserial program is installed, then execute it
				if [[ $AVAILABLE_SETSERIAL == "yes" ]]
				then

					# setserial is really about serial port UART chips and
					# does not like USB based serial ports
					if [[ ${EACH_SERIAL_DEVICE:1:6} != "ttyUSB" ]]
					then

						raw_caption "caption_setserial" "setserial $EACH_SERIAL_DEVICE"
						raw_open
						setserial -a $EACH_SERIAL_DEVICE >> $HTML 2>&1
						raw_close
					fi

				else
					echo "'setserial' is not available on this system." >> $HTML 2>&1
				fi

				line

				raw_caption "caption_stty" "stty $EACH_SERIAL_DEVICE"
				raw_open
				stty -a < $EACH_SERIAL_DEVICE >> $HTML 2>&1
				raw_close

				# Now that we've seen/processed a port, set the seen to yes
				SERIAL_PORTS_SEEN="yes"

			fi # endif - can we execute stty on the serial port?


		fi # endif - do we have a serial port device in /dev/ ?
	done # loop - process serial ports by number 0..9
done # loop - process serial port prefixes 'S' and 'USB'

# If we haven't seen any serial ports, report it cleanly to the user
if [[ $SERIAL_PORTS_SEEN == "no" ]]
then
	raw_open
	line "There are no physical serial ports on this system."
	raw_close
fi

#--------------------------------------------------------------------------
#
# X-Windows Graphics
#
#--------------------------------------------------------------------------

section "section_xwindows" "X-Windows"

# Nice idea, but we can't attach to another X display.. yet?

# Default to skip - assume we're on a non graphical system
MY_XDISPLAY=""

# If the user has specified an X display to report on, use that.
if [[ $DEF_XDISPLAY != "null" ]]
then
	MY_XDISPLAY="-display $DEF_XDISPLAY"
else 

	# User hasn't specified a particular X display to use.

	# Is this script running within one?
	if [[ $DISPLAY != "" ]]
	then

		# Empty out MY_XDISPLAY so clients just use the env $DISPLAY setting
		MY_XDISPLAY=""
	else
		MY_XDISPLAY="skip"
	fi
fi

if [[ $DEBUG = "yes" ]]
then
	echo "X-Windows: DISPLAY $DISPLAY"
	echo "X-Windows: DEF_XDISPLAY $DEF_XDISPLAY"
	echo "X-Windows: MY_XDISPLAY $MY_XDISPLAY"
fi

item_title "item_xrandr"	"RandR - X Resize, Rotate and Reflect Extension" "xrandr"

if [[ $MY_XDISPLAY != "skip" ]]
then
	textarea_open 120 24
	xrandr $MY_XDISPLAY >> $HTML 2>&1 
	textarea_close
else
	raw_open
	line "No X Display is available for reporting."
	raw_close
fi

item_title "item_dpyinfo"	"X Display Info" "xdpyinfo"

if [[ $MY_XDISPLAY != "skip" ]]
then
	textarea_open 120 24
	xdpyinfo $MY_DISPLAY >> $HTML 2>&1 
	textarea_close
else
	raw_open
	line "No X Display is available for reporting."
	raw_close
fi

item_title "item_xvinfo"	"Xvideo info" "xvinfo"

if [[ $MY_XDISPLAY != "skip" ]]
then
	textarea_open 120 24
	xvinfo $MY_XDISPLAY >> $HTML 2>&1 
	textarea_close
else
	raw_open
	line "No X Display is available for reporting."
	raw_close
fi

item_title "item_glxinfo"	"GLX Info" "glxinfo"

if [[ $MY_XDISPLAY != "skip" ]]
then
	textarea_open 120 24
	glxinfo $MY_XDISPLAY >> $HTML 2>&1
	textarea_close
else
	raw_open
	line "No X Display is available for reporting."
	raw_close
fi

#--------------------------------------------------------------------------
#
# Hardware Summary - 
#
#--------------------------------------------------------------------------

section "section_hw_summary" "Hardware Summary"

item_title "item_product"		"Product Name" "dmidecode -s system-product-name"
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s system-product-name >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_processor_line"	"Processor Summary" "dmidecode -s processor-version"
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s processor-version | head -1 >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_memsum"			"Memory" "/proc/meminfo" 
raw_open
cat /proc/meminfo | grep MemTotal >> $HTML 2>&1
raw_close

item_title "item_bios_vendor"	"BIOS Vendor" "dmidecode -s bios-vendor"
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s bios-vendor >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_bios_vers"		"BIOS Version" "dmidecode -s bios-version"
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s bios-version  >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_bios_date"		"BIOS Release Date" "dmidecode -s bios-release-date"
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s bios-release-date  >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_lsinitrd" 		"initrd information" "lsinitrd"

if [[ $DIST_NAME == "Suse" ]]
then
	MY_KERNEL=$(uname -a | cut --delimiter=" " -f 3)
	MY_INITRD="/boot/initrd-$MY_KERNEL"
fi

if [[ $AVAILABLE_LSINITRD == "yes" ]]
then
	# Present the lsinitrd information in an HTML textarea box
	textarea_open 120 24
	if [[ $DIST_NAME == "Suse" ]]
	then
		lsinitrd -l $MY_INITRD >> $HTML 2>&1
	else
		lsinitrd >> $HTML 2>&1
	fi
	textarea_close

	# Send the raw output to an ASCII file
	if [[ $DIST_NAME == "Suse" ]]
	then
		lsinitrd -l $MY_INITRD >> $FILE_INITRD 2>&1
	else
		lsinitrd >> $FILE_INITRD 2>&1
	fi

	helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_INITRD target=_file_initrd>separate lsinitrd file.</a>"
else
	raw_open
	line "lsinitrd is not available on this system."
	raw_close
fi

#--------------------------------------------------------------------------
#
# Processor/CPU Details
#
#--------------------------------------------------------------------------

section "section_processor" "Processor Information"

item_title "item_proc_family"	"Processor Family" "dmidecode -s processor-family"
# first line only please
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s processor-family | head -1 >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_proc_vers"		"Processor Version" "dmidecode -s processor-version"
# first line only please
raw_open
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode -s processor-version | head -1 >> $HTML 2>&1
else
	line "'dmidecode' is not available or does not work on this system."
fi
raw_close

item_title "item_proc_count"		"Processor Count" ""
raw_open
line "$(cat /proc/cpuinfo | grep processor | wc -l) count of $(grep 'model name' /proc/cpuinfo | head -1 | cut -c 14-80) logical CPUs"
raw_close

item_title "item_processor_lscpu" "Processor Details" "lscpu"
raw_open
if [[ $AVAILABLE_LSCPU == "yes" ]]
then
	lscpu >> $HTML 2>&1
else
	line "lscpu is not available on this system." 
fi
raw_close

item_title "item_processor_lscpue" "Processor List " "lscpu -e"
raw_open
if [[ $AVAILABLE_LSCPU == "yes" ]]
then
	# If QUIRK_LSCPU = "noext" then we don't have the -e (extended) option
	if [[ $QUIRK_LSCPU != "noext" ]]
	then
		lscpu -e >> $HTML 2>&1
	else
		# QUIRK: Ubuntu, LinuxMint
		line "QUIRK: 'lscpu -e' is not available with this distribution."
	fi
else
	line "lscpu is not available on this system."
fi
raw_close

item_title "item_processor_over"	"First Processor" "cat proc/cpuinfo"
raw_open

# Do we have more than one CPU?
if [[ $(grep processor /proc/cpuinfo | wc -l ) -gt 1 ]]
then

	# more than one CPU

	ENDLINE=$(grep -n processor /proc/cpuinfo  | grep ": 1$" | cut -f 1 --delimiter=":")

	# calculate how many lines to just show the first's detail
	FIRSTCPU=$(expr $ENDLINE - 1)

	# Show /proc/cpuinfo for first cpu only
	cat /proc/cpuinfo | head --lines $FIRSTCPU >> $HTML 2>&1
else
	# only one CPU, just cat /proc/cpuinfo to show detail for the chip we're using.
	cat /proc/cpuinfo >> $HTML 2>&1
fi

raw_close

cat /proc/cpuinfo >> $FILE_CPU

helpful_tip "<strong>Tip:</strong> Detailed information is available in the <a href=file:$BASE_FILE_CPU target=_file_cpu>separate cpu info file.</a>"

item_title "item_buddyinfo"		"Buddy Memory" "cat /proc/buddyinfo"

raw_open
	cat /proc/buddyinfo >> $HTML 2>&1
raw_close 

item_title "item_meminfo"		"Memory Info" "cat /proc/meminfo"
raw_open
cat /proc/meminfo >> $HTML 2>&1
raw_close

item_title "item_freemem"		"Free Memory" "free --giga"
raw_open
if [ $(free -V | grep procps-ng | wc -l) -gt 0 ]
then
	free --human >> $HTML 2>&1
else
	free -m >> $HTML 2>&1
fi
raw_close

item_title "item_mtrr"			"MTRR" "cat /proc/mtrr"
raw_open
if [[ -f /proc/mtrr ]]
then
	cat /proc/mtrr >> $HTML 2>&1
else
	line "This system doesn't have /proc/mtrr, is it a virtual machine?"
fi
raw_close

item_title "item_numashow"		"NUMA Topology" "numactl --show"

if [[ $AVAILABLE_NUMACTL == "yes" ]]
then
	raw_open
	numactl --show >> $HTML 2>&1
	raw_close 
	helpful_tip "<strong>Tip:</strong> 'numactl --show' describes the NUMA policies for the current process.  It can be useful to see how physical CPUs and memory are organized."

else
	raw_open
	line "numactl is not available."
	raw_close 
fi

item_title "item_numahw"			"NUMA Memory Topology" "numactl --hardware"
if [[ $AVAILABLE_NUMACTL == "yes" ]]
then
	raw_open
	numactl --hardware >> $HTML 2>&1
	raw_close

	helpful_tip "<p><strong>Tip:</strong> 'numactl --hardware' lists each node in the NUMA domain and produces table showing the cost of memory access from one node to another node."
else
	raw_open
	line "numactl is not available."
	raw_close
fi

#--------------------------------------------------------------------------
#
# Interrupt Details
#
#--------------------------------------------------------------------------

section "section_inter" "Interrupts" "cat /proc/interrupts"
#textarea_open 120 24
#cat /proc/interrupts >> $HTML 2>&1
#textarea_close
line "<table border=1>"
cat /proc/interrupts | awk -F "  " '{print "<tr> <td>"$1"</td><td>"$2"</td><td>"$3"</td><td>"$4"</td><td>"$5"</td><td>"$6"</td><td>"$7"</td><td>"$8"</td></tr>"}' >> $HTML 2>&1
line "</table>"

section "section_inter" "Interrupts" "cat /proc/interrupts"
textarea_open 120 24
cat /proc/interrupts >> $HTML 2>&1
textarea_close

helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_INTER target=_file_inter>separate interrupts info file.</a><br>" >> $HTML 2>&1

cat /proc/interrupts >> $FILE_INTER

#--------------------------------------------------------------------------
#
# PCI Expansion Bus & Card Details
#
#--------------------------------------------------------------------------

section "section_pci" "Expansion Cards"
 
#item_title "item_cards"			"Expansion cards" "sutl cards"

#raw_open
#FILE_EXISTS="no"
#check_for_program sutl
#if [[ $FILE_EXISTS == "yes" ]]
#then
#	sutl cards >> $HTML 2>&1
#else
#	line "'sutl' utility not available, cannot execute 'sutl cards'" 
#fi
#raw_close

item_title "item_iomem"			"Peripheral IO memory" "cat /proc/iomem"
IOMEM_LINES=$(cat /proc/iomem | wc -l)
text_open $IOMEM_LINES 120 24
cat /proc/iomem >> $HTML 2>&1 
text_close

item_title "item_ioports"		"Peripheral IO ports" "cat /proc/ioports"
IOPORT_LINES=$(cat /proc/ioports | wc -l)
text_open $IOPORT_LINES 120 24
cat /proc/ioports >> $HTML 2>&1 
text_close

item_title "item_dma"		"Peripheral DMA" "cat /proc/dma"
# Show a short raw box if we only have a few lines, textarea if many
DMA_LINES=$(cat /proc/dma | wc -l)
text_open $DMA_LINES 120 24
cat /proc/dma >> $HTML 2>&1
text_close

item_title "item_devices" 		"Devices" "cat /proc/devices"
# Show a short raw box if we only have a few lines, textarea if many
DEVICE_LINES=$(cat /proc/devices | wc -l)
text_open $DEVICE_LINES 120 24
cat /proc/devices >> $HTML 2>&1
text_close

item_title "item_lspci"			"PCI devices" "lspci"
# count the number of lines that will appear as output
if [[ $AVAILABLE_LSPCI == "yes" ]]
then
	LSPCI_LINES=$(lspci | wc -l)
fi

if [[ $LSPCI_LINES -eq 0 ]]
then
	# If we have 0 then report this to the user
	raw_open
	line "This system doesn't list any PCI devices, is it a virtual machine?"
	raw_close
else
	text_open $LSPCI_LINES 120 24
	lspci >> $HTML 2>&1 
	text_close
fi

item_title "item_lspcivv"	"PCI Devices Detail" "lspci -vv"
# Count the number of output lines
if [[ $AVAILABLE_LSPCI == "yes" && $AVAILABLE_LSPCI == "yes" ]]
then
	LSPCI_VV_LINES=$(lspci -vv | wc -l)
else
	LSPCI_VV_LINES=0
fi

# If we have more than 0, we need to report them
if [[ $LSPCI_VV_LINES -gt 0 ]]
then
	# pci output may contain > and < symbols which interfere with
	# HTML formatted output.  So we'll use sed to convert 
	# < to &lsaquo; and > to &rsaquo;

	text_open $LSPCI_VV_LINES 	120 24
	lspci -vv | sed "s/>/\&rsaquo;/g" | sed "s/</\&lsaquo;/g" >> $HTML 2>&1 
	text_close

	# Record this information into the raw file
	lspci -vv >> $FILE_PCI 2>&1
	# If we've recorded something into the file, then show this tip, too
	helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_PCI target=_file_pci>separate lspci file.</a>"

else
	raw_open
	line "This system doesn't list any PCI devices, is it a virtual machine?"
	raw_close

	# Place a warning in the text output file too in case the user
	# doesn't bother to look at this info in the HTML file first.
	echo "This system doesn't list any PCI devices, is it a virtual machine?">> $FILE_PCI 2>&1
fi

#--------------------------------------------------------------------------
#
# USB System Details
#
#--------------------------------------------------------------------------

section "section_usb" "USB System"

item_title "item_lsusb"			"USB Devices" "lsusb"
if [[ $AVAILABLE_LSUSB == "yes" && $LSUSB_WORKS == "yes" ]]
then
	# Setting LSUSB_LINES here is important, we use it to determine
	# how long the output of lsusb.py is later
	LSUSB_LINES=$(lsusb | wc -l)
	text_open $LSUSB_LINES 120 24
	lsusb >> $HTML 2>&1
	text_close
else
	raw_open
	line "The USB system doesn't appear to work. Is this a virtual machine?"
	raw_close
fi

item_title "item_lsusbpy"		"USB Devices Speed & Power" "lsusb.py"
if [[ $AVAILABLE_LSUSB == "yes" && $LSUSB_WORKS == "yes" ]]
then

	if [[ $AVAILABLE_LSUSBPY == "yes" ]]
	then

		LSUSBPY_LINES=$(lsusb.py | wc -l)
		text_open $LSUSBPY_LINES 120 24
		/usr/bin/lsusb.py -I >> $HTML 2>&1
		text_close
	else
		raw_open
		line "/usr/bin/lsusb.py is not available."
		raw_close
	fi
else
	raw_open
	line "The USB system doesn't appear to work. Is this a virtual machine?"
	raw_close
fi

item_title "item_lsusbv"			"USB Devices Detail" "lsusb -v"
if [[ $AVAILABLE_LSUSB == "yes" && $LSUSB_WORKS == "yes" ]]
then
	LSUSB_V_LINES=$(lsusb -v | wc -l)
	text_open $LSUSB_V_LINES 120 24
	lsusb -v >> $HTML 2>&1
	text_close
else
	raw_open
	line "The USB system doesn't appear to work. Is this a virtual machine?"
	raw_close
fi

item_title "item_lsusbt"			"USB Devices Tree" "lsusb -t"
if [[ $AVAILABLE_LSUSB == "yes" && $LSUSB_WORKS == "yes" ]]
then
	# redirect stderr to stdout as some information is sent 
	# to stderr too, not sure why.
	LSUSB_T_LINES=$(lsusb -t | wc -l)
	text_open $LSUSB_T_LINES 120 24
	lsusb -t >> $HTML 2>&1
	text_close
else
	raw_open
	line "The USB system doesn't appear to work. Is this a virtual machine?"
	raw_close
fi

#--------------------------------------------------------------------------
#
# System Board Details with dmidecode
#
#--------------------------------------------------------------------------

section "section_dmidecode" "System Board Information"

item_title "item_dmidecode" "System Board information" "dmidecode"
if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	textarea_open 120 24
	dmidecode >> $HTML 2>&1
	textarea_close 
else
	raw_open
	line "'dmidecode' is not available or does not work on this system."
	raw_close
fi

if [[ $AVAILABLE_DMIDECODE == "yes" && $DMIDECODE_WORKS == "yes" ]]
then
	dmidecode >> $FILE_DMI
	helpful_tip "Detailed information is available in the <a href=file:$BASE_FILE_DMI target=_file_dmi>separate dmidecode file.</a>"
fi

#--------------------------------------------------------------------------
#
# Network Devices
#
#--------------------------------------------------------------------------

section "section_network_devices" "Network Devices"

#item_title "item_sutlnics"		"Network cards" "sutl nics"
#FILE_EXISTS="no"
#check_for_program sutl
#raw_open
#if [[ $FILE_EXISTS == "yes" ]]
#then
#	sutl nics >> $HTML 2>&1
#else
#	line "# not available: sutl nics"
#fi
#raw_close

item_title "item_nicinfo" "Network port information" "nics"
if [ $PUBLIC_REPORT = "yes" ]
then
	raw_open
	line "This is a public report and no IP network information is included."
	raw_close
else
	raw_open
	nic_list >> $HTML 2>&1
	raw_close
fi

item_title "item_lshw_network"		"Network port hardware details" "lshw -c network"
if [[ $AVAILABLE_LSHW == "yes" ]]
then
	textarea_open 160 24
	lshw -c network >> $HTML 2>&1
	textarea_close	
else
	raw_open
	line "lshw is not available on this system."
	raw_close
fi

item_title "item_nicports"		"Network port detail information" "ifconfig, ethtool, ethtool -i"
if [ $PUBLIC_REPORT = "yes" ]
then
	raw_open
	line "This is a public report and no IP network information is included."
	raw_close
else

	# FIND A LIST OF NETWORK DEVICES:
	# 1: ip link list - lists all network devices
	# 2: Use only the first line using a regex that looks for '1:', '99:', etc
	# 3: From that first line, we only want the device name which is param #2
	# 4: remove the colon that sits to the right of the device name
	# 5: macvtap bridges (used with KVM) look like this:
	#    macvtap0@p10p1
	#    convert the "@" symbol to ATSYMBOL and then we'll use a bash
	#    parameter expansion below to remove all to the right of ATSYMBOL

	# Code borrowed from external 'nics' script
	for EACH_NIC in $(ip link list | grep -e "[0-9]: " | awk -F " " '{print $2}' | sed "s/://g" | sed "s/@/ATSYMBOL/" )
	do

		# If ATSYMBOL is present, remove everything to right of it so we have
		# just a simple name like macvtap0
		EACH_NIC=${EACH_NIC%%ATSYMBOL*}

		# Do raw_open/raw_close for each NIC so each is presented individually

		# We show network device information in both 'ip' and 'ifconfig'
		# style because users may be familiar with one style and trained
		# to easily review one over the other.
	
		raw_caption "caption_iplinkshow" "# ip -s link show $EACH_NIC"
		raw_open
		ip -s link show $EACH_NIC >> $HTML 2>&1
		raw_close

		raw_caption "caption_ifconfig" "# ifconfig $EACH_NIC"
		raw_open
		ifconfig $EACH_NIC >> $HTML 2>&1
		raw_close

		if [[ $AVAILABLE_ETHTOOL == "yes" ]]
		then

			if [[ $EACH_NIC == "lo" || ${EACH_NIC:0:7} == "vboxnet" ]]
			then
				raw_open
				line "Skipping ethtool on non-network port device $EACH_NIC"
				raw_close
			else

				raw_caption "caption_ethtool" "# ethtool $EACH_NIC"
				raw_open
				ethtool $EACH_NIC >> $HTML 2>&1
				raw_close

				line

				raw_caption "caption_ethtool_i" "# ethtool -i $EACH_NIC"
				raw_open
				ethtool -i $EACH_NIC >> $HTML 2>&1
				raw_close
			fi

		else
			raw_open
			line "ethtool is not available on this system." >> $HTML 2>&1
			raw_close
		fi

	done # on to next nic port in NIC_LIST

fi

#--------------------------------------------------------------------------
#
# Storage Resources
#
#--------------------------------------------------------------------------

section "section_storage" "Storage Devices"

#item_title "item_sutlhbas"	"Host Bus Adapter information" "sutl hbas"
#FILE_EXISTS="no"
#check_for_program sutl
#if [[ $FILE_EXISTS == "yes" ]]
#then
#	raw_open
#	sutl hbas >> $HTML 2>&1
#	raw_close
#else
#	line "'sutl' utility not available, can't execute 'sutl cards'" 
#fi

item_title "item_lsblk"		"Block Storage Devices" "lsblk"
if [[ $AVAILABLE_LSBLK == "yes" ]]
then
	# This is done earlier, but we'll repeat it for safety here.
	FSBLOCK_LINES=$(lsblk -fi | wc -l)
	text_open $FSBLOCK_LINES 160 24
	# -i option uses ASCII characters for tree relationships +--^ etc
	lsblk -i >> $HTML 2>&1
	text_close	
fi

item_title "item_lsscsi" "SCSI Information" "lsscsi"
if [[ $AVAILABLE_LSSCSI == "yes" ]]
then
	LSSCSI_LINES=$(lsscsi | wc -l)
	if [[ $LSSCSI_LINES -gt 0 ]]
	then
		text_open $LSSCSI_LINES 120 24
		lsscsi >> $HTML 2>&1
		text_close
	else
		raw_open
		line "There are no SCSI devices on your system. Maybe this is a virtual machine?"
		raw_close
	fi
else
	raw_open
	line "'lsscsi' is not available on this system."
	raw_close
fi

item_title "item_procscsi" "SCSI Information via proc" "cat /proc/scsi/scsi"
PROC_SCSI_LINES=$(cat /proc/scsi/scsi | grep -v "Attached" | wc -l)
if [[ $PROC_SCSI_LINES -gt 0 ]]
then
	text_open $PROC_SCSI_LINES 120 24
	cat /proc/scsi/scsi >> $HTML 2>&1
	text_close
else
	raw_open
	line "There are no SCSI devices being reported on this system. Is it a virtual machine?"
	raw_close
fi

#--------------------------------------------------------------------------
#
# Peripherals - General, Not Included Elsewhere
#
#--------------------------------------------------------------------------

section "section_periphs" "Peripherals"

item_title "item_cdinfo" "DVD/CD Drive Info" "cd-info"
# quirk: SLES 11 SP3 - no cd-info by default
if [[ $AVAILABLE_CDINFO == "yes" ]]
then
	textarea_open 120 24
	cd-info >> $HTML 2>&1
	textarea_close
else
	raw_open
	line "cd-info is not available on this system"
	raw_close
fi

#--------------------------------------------------------------------------
#
# Virtualization
#
#--------------------------------------------------------------------------

section "section_virt" "Virtualization"

if [[ $DEF_SHOW_VIRT == "yes" ]]
then

	if [[ $AVAILABLE_VIRSH == "yes" ]]
	then
		item_title "item_kvminfo" "KVM Version" "modinfo kvm"
		raw_open
		modinfo kvm>> $HTML 2>&1
		raw_close

		item_title "item_kvmhwinfo" "KVM Hardware Version" "modinfo kvm_intel | modinfo kvm_amd"
		raw_open
		if [ $(lsmod | grep kvm_intel | wc -l) -gt 0 ]
		then
			modinfo kvm_intel >> $HTML 2>&1
		fi
		if [ $(lsmod | grep kvm_amd | wc -l) -gt 0 ]
		then
			modinfo kvm_amd >> $HTML 2>&1
		fi
		raw_close

		# virsh may be installed but with no hypervisor running, all our 
		# attempts to use it will result in errors.  We don't want to give the
		# user raw, unprocessed errors repeatedly, so we'll check to see if it
		# works here, report the error in detail with the first virsh call
		# then minimize the error reporting on subsequent virsh data points
		# Assume no
		VIRSH_WORKS="no"

		virsh version > /dev/null 2>&1
	
		# Check for error, if none, it works.
		if [[ $? -eq 0 ]]
		then
			VIRSH_WORKS="yes"
		fi

		item_title "item_virshvers"	"Virtualization version" "virsh version"
		raw_open
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			virsh version >> $HTML 2>&1
		else
			# Output this line to let the user know we're aware virsh isn't working
			line "virsh operations are not available on this system."
			line
			line "virsh version output:"
			# Now call virsh again and let it report the error to the user.
			virsh version >> $HTML 2>&1
		fi
		raw_close
	
		item_title "item_virshnodeinfo"	"Virtualization nodes" "virsh nodeinfo"
		raw_open
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			virsh nodeinfo >> $HTML 2>&1
		else
			# Output this line to let the user know we're aware virsh isn't working
			line "virsh operations are not available on this system."
		fi
		raw_close
	
		item_title "item_virshnodecpu"	"Virtualization nodes" "virsh nodecpustats"
		raw_open
		if [[ $DIST_FAMILY == "Redhat" ]] && [[ $DIST_VERSION_ID == "5" ]]
		then
			line "virsh nodecpustats is not available with this distribution and release"
		else
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				virsh nodecpustats >> $HTML 2>&1
			else
				# Output this line to let the user know we're aware virsh isn't working
				line "virsh operations are not available on this system."
			fi
		fi
		raw_close

		item_title "item_virshnodemem"	"Virtualization nodes" "virsh nodeinfo"
		if [[ $DIST_FAMILY == "Redhat" ]] && [[ $DIST_VERSION_ID == "5" ]]
		then
			line "virsh nodememstats is not available with this distribution and release"
		else
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				raw_open
				virsh nodememstats >> $HTML 2>&1 
				raw_close
			else
				# Output this line to let the user know we're aware virsh isn't working
				raw_open
				line "virsh operations are not available on this system."
				raw_close
			fi
		fi

		item_title "item_virshnodedevlist"	"Virtualization nodes devices" "virsh nodedev-list"
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			textarea_open 120 24
			virsh nodedev-list>> $HTML 2>&1
			textarea_close
		else
			# Output this line to let the user know we're aware virsh isn't working
			raw_open
			line "virsh operations are not available on this system."
			raw_close
		fi

		item_title "item_virshnodedevxml"	"Virtualization nodes devices xml" "virsh nodedev-dumpxml"
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			for EACH_DEV in $(virsh nodedev-list)
			do	
				raw_caption "caption_nodedev_dumpxml" "# virsh nodedev-dumpxml $EACH_DEV"
				raw_open
				virsh nodedev-dumpxml $EACH_DEV | sed "s/>/\&rsaquo;/g" | sed "s/</\&lsaquo;/g" >> $HTML 2>&1 
				raw_close
			done
		else
			# Output this line to let the user know we're aware virsh isn't working
			raw_open
			line "virsh operations are not available on this system."
			raw_close
		fi

		item_title "item_virsh_iflist" "Virtualization Interface List" "virsh iface-list"
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			VIRSH_IFACE_COUNT=$(virsh iface-list | tail -n +4 | wc -l)
			if [[ $VIRSH_IFACE_COUNT -eq 0 ]]
			then
				raw_open
				line "There are no interfaces defined for this system."
				raw_close
			else
				text_open $VIRSH_IFACE_COUNT 120 24
				virsh iface-list >> $HTML 2>&1
				text_close
			fi
		else
			# Output this line to let the user know we're aware virsh isn't working
			raw_open
			line "virsh operations are not available on this system."
			raw_close
		fi

		item_title "item_virsh_netlist" "Virtualization Network List" "virsh net-list"
		if [[ $VIRSH_WORKS == "yes" ]]
		then
			VIRSH_NETLIST_COUNT=$(virsh net-list | tail -n +4 | wc -l)
			if [[ $VIRSH_NETLIST_COUNT -eq 0 ]]
			then
				raw_open
				line "There are no networks defined for this system."
				raw_close
			else
				text_open $VIRSH_NETLIST_COUNT 120 24
				virsh net-list >> $HTML 2>&1
				text_close
			fi
		else
			# Output this line to let the user know we're aware virsh isn't working
			raw_open
			line "virsh operations are not available on this system."
			raw_close
		fi

	else
		raw_open
		line "virsh is not available in this environment."
		raw_close
	fi
else
	echo "Skipping Virtualization Configuration (--novirt)"
	raw_open
	line "Skipping Virtualization Configuration (--novirt)"
	raw_close
	line
fi # If DEF_SHOW_VIRT is yes, show this section.

#--------------------------------------------------------------------------
#
# Virtual Machines
#
#--------------------------------------------------------------------------

section "section_vms" "Virtual Machines"

if [[ $DEF_SHOW_VIRT == "yes" ]]
then

	item_title "item_vmlist"	"Virtual Machines Defined" "virsh list --all"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then
		# Even on a system with no VMs, a header will be produced by virsh
		# So attempt to list all VMs by starting with line four of the output
		VIRSH_VM_COUNT=$(virsh list --all | tail -n +4 | wc -l)
		if [[ $VIRSH_VM_COUNT -gt 0 && $VIRSH_VM_COUNT -le 15 ]]
		then
			raw_open
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				virsh list --all >> $HTML 2>&1
			else
				# Output this line to let the user know we're aware virsh isn't working
				line "virsh operations are not available on this system."
			fi
			raw_close
		elif [[ $VIRSH_VM_COUNT -gt 0 && $VIRSH_VM_COUNT -gt 15 ]]
		then
			textarea_open 120 24
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				virsh list --all >> $HTML 2>&1
			else
				# Output this line to let the user know we're aware virsh isn't working
				line "virsh operations are not available on this system."
			fi
			textarea_close
		else
			raw_open
			line "There are no virtual machines defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open
		line "virsh operations are not available on this system."
		raw_close
	fi

	item_title "item_virsh_pool_list" "Virtualization Storage Pool List" "virsh pool-list"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then

		VIRSH_POOL_COUNT=$(virsh pool-list | tail -n +4| wc -l)
		if [[ $VIRSH_POOL_COUNT -gt 0 && $VIRSH_POOL_COUNT -le 15 ]]
		then
			raw_open
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				virsh pool-list >> $HTML 2>&1
			else
				# Output this line to let the user know we're aware virsh isn't working
				line "virsh operations are not available on this system."
			fi
			raw_close
		elif [[ $VIRSH_POOL_COUNT -gt 0 && $VIRSH_POOL_COUNT -gt 15 ]]
		then
			textarea_open 120 24
			if [[ $VIRSH_WORKS == "yes" ]]
			then
				virsh pool-list >> $HTML 2>&1
			else
				# Output this line to let the user know we're aware virsh isn't working
				line "virsh operations are not available on this system."
			fi
			textarea_close
		else
			raw_open
			line "There are no pool objects defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open
		line "virsh operations are not available on this system."
		raw_close
	fi

	item_title "item_virsh_pool_info" "Virtualization Storage Pool Info" "virsh pool-info"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then
		if [[ $VIRSH_POOL_COUNT -gt 0 ]]
		then
			for EACH_POOL in $(virsh pool-list | tail -n +3 | awk '{ FS = " "; print $1 }')
			do
				raw_caption "caption_pool_info" "Pool info for pool '$EACH_POOL'"
				raw_open
				virsh pool-info $EACH_POOL >> $HTML 2>&1
				raw_close
			done
		else
			raw_open
			line "There are no pool objects defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open
		line "virsh operations are not available on this system."
		raw_close
	fi

	item_title "item_virsh_vol_list" "Virtualization Storage Volume List" "virsh vol-list"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then
		if [[ $VIRSH_POOL_COUNT -gt 0 ]]
		then
			for EACH_POOL in $(virsh pool-list | tail -n +3 | awk '{ FS = " "; print $1 }' | sed 's/ *$//')
			do
				raw_caption "caption_virsh_vol_pool" "Volumes in storage pool '$EACH_POOL'"
				raw_open
				virsh vol-list $EACH_POOL >> $HTML 2>&1
				raw_close
			done
		else
			raw_open
			line "There are no pool objects defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open
		line "virsh operations are not available on this system."
		raw_close
	fi

	item_title "item_virsh_vol_info" "Virtualization Storage Volume Info" "virsh vol-info"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then
		if [[ $VIRSH_POOL_COUNT -gt 0 ]]
		then
			for EACH_POOL in $(virsh pool-list | tail -n +3 | awk '{ FS = " "; print $1 }' | sed 's/ *$//')
			do

				for EACH_VOL in $(virsh vol-list $EACH_POOL | tail -n +3 | awk '{ FS = " "; print $1 }' | sed 's/ *$//')
				do
					raw_caption "caption_volinfo2" "Volume info for volume '$EACH_VOL' in storage pool '$EACH_POOL'"
					raw_open
					virsh vol-info --pool $EACH_POOL $EACH_VOL >> $HTML 2>&1
					raw_close
				done
			done
		else
			raw_open
			line "There are no pool objects defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open
		line "virsh operations are not available on this system."
		raw_close
	fi

	item_title "item_vm_details" "Virtual Machine Details" "--"
	if [[ $AVAILABLE_VIRSH == "yes" && $VIRSH_WORKS == "yes" ]]
	then
		if [[ $VIRSH_VM_COUNT -gt 0 ]]
		then
			for EACH_VM in $(virsh list --all | tail -n +3 | awk '{ FS = " "; print $2 }' | sed 's/ *$//')
			do

				# Determine the state of the VM: Running, Shut offf

				QUIRK_VIRSH_DOMSTATE="no-reason"

				# Acquire the state of the VM and a possible reason for its state
				# If Quirk_virsh_domstate is set, we don't have the -reason feature
				if [[ $QUIRK_VIRSH_DOMSTATE == "no-reason" ]]
				then
					VM_STATE=$(virsh domstate $EACH_VM)
				else
					VM_STATE=$(virsh domstate $EACH_VM --reason)
				fi

				# Report the name of the VM and its current state
				raw_caption "caption_vmstate" "Virtual Machine '$EACH_VM' is $VM_STATE"

				# Try to acquire the description of this VM
				if [[ QUIRK_VIRSH_DESC != "no-desc" ]]
				then
					VM_DESC=$(virsh desc $EACH_VM)


					# If the VM has something other than "No description" then report it.
					if [[ ${VM_DESC:1:14} != "No description" ]]
					then
						# Report the VM description text
						raw_caption "caption_vmdesc" "'$VM_DESC'"
					fi
				fi

				# Report technical information on the VM like its ID, UUID, Memory, CPU
				raw_open
				virsh dominfo $EACH_VM >> $HTML 2>&1
				raw_close

				# Report storage devices defined for the VM
				raw_caption "caption_vmstorage" "Defined storage devices for VM '$EACH_VM' "
				raw_open
				virsh domblklist $EACH_VM >> $HTML 2>&1
				raw_close

				# Report network interfaces defined for the VM
				raw_caption "caption_vmstorage" "Defined network interfaces for VM '$EACH_VM':"
				raw_open
				virsh domiflist $EACH_VM >> $HTML 2>&1
				raw_close

			done
		else
			raw_open
			line "There are no virtual machines defined for this system."
			raw_close
		fi
	else
		# Output this line to let the user know we're aware virsh isn't working
		raw_open

		if [[ $AVAILABLE_VIRSH == "no" ]]
		then
			# We don't have the virsh command
			line "virsh is not available on this system."
		else
			# We have the virsh command but we don't have libvirt working
			line "virsh operations are not available on this system."
		fi
		raw_close
	fi

else
	echo "Skipping Virtual Machines (--novirt)"
	raw_open
	line "Skipping Virtual Machines (--novirt)"
	raw_close
fi # If DEF_SHOW_VIRT is yes, show this section.

#--------------------------------------------------------------------------
#
# XEN Virtualization
#
#--------------------------------------------------------------------------

section "section_xen" "Xen Virtualization"

if [[ $DEF_SHOW_VIRT == "yes" ]]
then

	item_title "item_xenconfig" "Xen Configuration" "cat /etc/xen/xend-config.sxp"

	if [[ $XEN_HOST == "yes" ]]
	then
		XEN_CONFIG_LINES=$(cat /etc/xen/xend-config.sxp | wc -l)
		if [[ $XEN_CONFIG_LINES -le 15 ]]
		then
			raw_open
			cat /etc/xen/xend-config.sxp >> $HTML 2>&1
			raw_close
		else
			textarea_open 120 24
			cat /etc/xen/xend-config.sxp >> $HTML 2>&1
			textarea_close
		fi
	else
		raw_open
		line "This is not a Xen hypervisor <strong>host</strong> system."
		raw_close
	fi

else

	echo "Skipping Xen Virtualization (--novirt)"
	raw_open
	line "Skipping Xen Virtualization (--novirt)"
	raw_close

fi # If DEF_SHOW_VIRT is yes, show this section.

#--------------------------------------------------------------------------
#
# End Of Report - Complete and Process Output Files
#
#--------------------------------------------------------------------------

line "</body></html>" >> $HTML 2>&1

# if we see an existing file, remove it so we can replace it.
if [ -f "$OUTPUT_DIR.tar" ]
then
	rm "$OUTPUT_DIR.tar"
fi
# if we see an existing file, remove it so we can replace it.
if [ -f "$OUTPUT_DIR.tar.gz" ]
then
	rm "$OUTPUT_DIR.tar.gz"
fi

# If we ran this script using sudo or su -- anything but a real
# login as 'root', then change the output directory and files
# to the non-root username
# ONLY CHANGE FILES WE MADE - No wildcards!! - maxwell

if [[ $SUDO_USER != "root" ]]
then
	if [[ $DEBUG = "yes" ]]
	then
		echo "Changing ownership of output directory to $SUDO_USER"
	fi

	chown $SUDO_USER "${OUTPUT_DIR}" 

	for EACH_FILE in \
		"${FILE_DMI}" "${FILE_CPU}" "${FILE_MSGS}" "${FILE_SYSLOG}" \
		"${FILE_DMESG}" "${FILE_DMESG_NOTIME}" "${FILE_INTER}" \
		"${FILE_PCI}" "${FILE_INITRD}"
	do
		if [[ $DEBUG = "yes" ]]
		then
			echo "Changing ownership of ${EACH_FILE} to $SUDO_USER"
		fi
		if [[ -f $EACH_FILE ]]
		then
			chown $SUDO_USER "${EACH_FILE}"
		fi
	done
fi

echo -e "\nTaring up results."
tar cf "$OUTPUT_DIR.tar" "$OUTPUT_DIR"

echo "Compressing tar file."
gzip -9 "$OUTPUT_DIR.tar"

FILE_EXISTS="no"
check_for_program zip
if [[ $FILE_EXISTS == "yes" ]]
then
	zip -qrl "$OUTPUT_DIR.zip" "$OUTPUT_DIR"
fi

if [[ $SUDO_USER != "root" ]]
then
	if [[ $DEBUG = "yes" ]]
	then
		echo "Changing ownership of output directory to $SUDO_USER"
	fi

	if [[ -f $OUTPUT_DIR.tar.gz ]]
	then
		chown $SUDO_USER "${OUTPUT_DIR}.tar.gz" 
	fi

	if [[ -f $OUTPUT_DIR.zip ]]
	then
		chown $SUDO_USER "${OUTPUT_DIR}.zip"
	fi
fi

echo -e "Birdseye capture complete: $OUTPUT_DIR.tar.gz\n"
